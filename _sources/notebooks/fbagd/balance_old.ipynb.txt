{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "89c876b4-8497-499f-a413-26ad32cec39e",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from scipy import linalg\n",
    "from scipy.special import logsumexp\n",
    "import seaborn as sns\n",
    "import pandas as pd\n",
    "import os\n",
    "from inspect import getmembers\n",
    "import matplotlib.pyplot as plt\n",
    "import networkx as nx\n",
    "from sklearn.preprocessing import MinMaxScaler, StandardScaler\n",
    "import dill\n",
    "from equilibrator_api import ComponentContribution, Q_, Reaction\n",
    "import requests\n",
    "import xmltodict\n",
    "import pint\n",
    "import cvxpy as cp\n",
    "import itertools\n",
    "import copy\n",
    "\n",
    "sns.set(style='darkgrid', palette='viridis', context='talk')\n",
    "\n",
    "os.chdir(os.path.expanduser('~/vivarium-ecoli'))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "82a34091-b89a-4a8b-b49e-ce86aeab25c6",
   "metadata": {},
   "source": [
    "A + B -E1> C -E2> D\n",
    "\n",
    "B -E3> F\n",
    "\n",
    "A -E4> G"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2cc077b2-8c38-4065-b306-2e91611fd975",
   "metadata": {
    "jp-MarkdownHeadingCollapsed": true,
    "tags": []
   },
   "source": [
    "# Testing eQuilibrator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "77f87609-2312-4734-8970-05177c5c3434",
   "metadata": {},
   "outputs": [],
   "source": [
    "cc = ComponentContribution()\n",
    "\n",
    "# optional: changing the aqueous environment parameters\n",
    "cc.p_h = Q_(7.4)\n",
    "cc.p_mg = Q_(3.0)\n",
    "cc.ionic_strength = Q_(\"0.25M\")\n",
    "cc.temperature = Q_(\"298.15K\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "90008655-107b-487c-b60b-a98b12137dd6",
   "metadata": {},
   "outputs": [],
   "source": [
    "from equilibrator_api import Reaction\n",
    "compound_ids = [\"WATER\", \"ADP\", \"ATP\", \"Pi\"]\n",
    "compound_dict = {cid : cc.get_compound(f\"metacyc.compound:{cid}\") for cid in compound_ids}\n",
    "atpase_reaction = Reaction({\n",
    "    compound_dict[\"ATP\"]: -1,\n",
    "    compound_dict[\"WATER\"]: -1,\n",
    "    compound_dict[\"ADP\"]: 1,\n",
    "    compound_dict[\"Pi\"]: 1,\n",
    "})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "ac886c79-121d-4d77-9ba0-eb4b25d19039",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "<Measurement(-29.144472212600157, 0.3042778553577678, kilojoule / mole)>",
      "text/html": "(-29.14 &plusmn; 0.30) kilojoule/mole",
      "text/latex": "$\\left(-29.14 \\pm 0.30\\right)\\ \\frac{\\mathrm{kilojoule}}{\\mathrm{mole}}$"
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "standard_dg_prime = cc.standard_dg_prime(atpase_reaction)\n",
    "standard_dg_prime"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "c6be2265-c9ec-45cf-8b87-8ca2df1376dd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(-44.8 +/- 0.6) kilojoule / mole\n"
     ]
    }
   ],
   "source": [
    "cytoplasmic_p_h = Q_(7.5)\n",
    "cytoplasmic_ionic_strength = Q_(\"250 mM\")\n",
    "periplasmic_p_h = Q_(7.0)\n",
    "periplasmic_ionic_strength = Q_(\"200 mM\")\n",
    "e_potential_difference = Q_(\"0.15 V\")\n",
    "cytoplasmic_reaction = \"bigg.metabolite:pep = bigg.metabolite:g6p + bigg.metabolite:pyr\"\n",
    "periplasmic_reaction = \"bigg.metabolite:glc__D = \"\n",
    "\n",
    "cc = ComponentContribution()\n",
    "cc.p_h = cytoplasmic_p_h\n",
    "cc.ionic_strength = cytoplasmic_ionic_strength\n",
    "standard_dg_prime = cc.multicompartmental_standard_dg_prime(\n",
    "    cc.parse_reaction_formula(cytoplasmic_reaction),\n",
    "    cc.parse_reaction_formula(periplasmic_reaction),\n",
    "    e_potential_difference=e_potential_difference,\n",
    "    p_h_outer=periplasmic_p_h,\n",
    "    ionic_strength_outer=periplasmic_ionic_strength,\n",
    ")\n",
    "\n",
    "print(standard_dg_prime)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "3c97b6b4-77e2-4ddb-926c-b39f4780811b",
   "metadata": {},
   "outputs": [],
   "source": [
    "cc.get_compound_by_inchi(\"WQZGKKKJIJFFOK-GASJEMHNSA-N\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fb140010-52ab-4edd-844e-a3645b3d5a41",
   "metadata": {
    "jp-MarkdownHeadingCollapsed": true,
    "tags": []
   },
   "source": [
    "# Using eQuilibrator to generate equilibrium constants"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "6cd11cad-2e4b-4cb7-bec6-6d3e4f7b21bd",
   "metadata": {},
   "outputs": [],
   "source": [
    "s = requests.Session() # create session\n",
    "# Post login credentials to session:\n",
    "s.post('https://websvc.biocyc.org/credentials/login/', data={'email':'cellulararchitect@protonmail.com', 'password':'Cellman0451'})\n",
    "# Issue web service request:\n",
    "r = s.get('https://websvc.biocyc.org/getxml?id=ECOLI:6PFRUCTPHOS-RXN&detail=low&fmt=json')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "0ceafb21-0bf4-41d7-8e07-c159e8b73302",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "'F16ALDOLASE-ENZRXN-CLASSI'"
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "name = 'F16ALDOLASE-RXN'\n",
    "\n",
    "r = s.get(f'https://websvc.biocyc.org/getxml?id=ECOLI:{name}&detail=low&fmt=json')\n",
    "o = xmltodict.parse(r.content)['ptools-xml']\n",
    "o['Reaction']['enzymatic-reaction']['Enzymatic-Reaction'][0]['@frameid']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "837d6516-fa3c-4b71-ba39-4a98bb9689d3",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "{'6PFRUCTPHOS-RXN': <equilibrator_api.phased_reaction.PhasedReaction at 0x104dfd0a0>,\n 'F16ALDOLASE-RXN': <equilibrator_api.phased_reaction.PhasedReaction at 0x17d229c10>,\n '2TRANSKETO-RXN': <equilibrator_api.phased_reaction.PhasedReaction at 0x289ddfa90>,\n 'TRIOSEPISOMERIZATION-RXN': <equilibrator_api.phased_reaction.PhasedReaction at 0x289df1550>}"
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "rxns_names = ['6PFRUCTPHOS-RXN', 'F16ALDOLASE-RXN', '2TRANSKETO-RXN', 'TRIOSEPISOMERIZATION-RXN']\n",
    "\n",
    "rxns_dict = {}\n",
    "stoich_dict = {}\n",
    "regulation_dict = {}\n",
    "\n",
    "for name in rxns_names:\n",
    "    r = s.get(f'https://websvc.biocyc.org/getxml?id=ECOLI:{name}&detail=low&fmt=json')\n",
    "    rxn = xmltodict.parse(r.content)['ptools-xml']\n",
    "\n",
    "    rxn_dict = {}\n",
    "    stoich_loop_dict = {}\n",
    "    regulation_loop_dict = {}\n",
    "    left = rxn['Reaction']['left']\n",
    "    right = rxn['Reaction']['right'] \n",
    "    \n",
    "    # i will know exact complex in model (connected to rxn), but for now will pick random\n",
    "    enz_rxn = rxn['Reaction']['enzymatic-reaction']['Enzymatic-Reaction']\n",
    "    \n",
    "    if type(left) is dict:\n",
    "        left = [left]\n",
    "    \n",
    "    if type(right) is dict:\n",
    "        right = [right]\n",
    "        \n",
    "    if type(enz_rxn) is dict:\n",
    "        enz_rxn = [enz_rxn]\n",
    "    \n",
    "    enz_rxn_id =  enz_rxn[0]['@frameid']\n",
    "    re = s.get(f'https://websvc.biocyc.org/getxml?id=ECOLI:{enz_rxn_id}&detail=high&fmt=json')\n",
    "    oe = xmltodict.parse(re.content)['ptools-xml']['Enzymatic-Reaction']['regulated-by']['Regulation']\n",
    "    \n",
    "    if type(oe) is dict:\n",
    "        oe = [oe]\n",
    "        \n",
    "    # add regulators, target regulator directly with id to get info like irreversible, etc\n",
    "    for regulator in oe:\n",
    "        reg_name = regulator['regulator']['Compound']['@frameid']\n",
    "        reg_type = regulator['mode']['#text']\n",
    "        reg_type = 1 if reg_type == '+' else -1\n",
    "        regulation_loop_dict[reg_name] = reg_type\n",
    "    \n",
    "    for mol in left:\n",
    "        if type(mol) is dict:\n",
    "            cid = mol['Compound']['@frameid']\n",
    "            mol_cc = cc.get_compound(f\"metacyc.compound:{cid}\")\n",
    "            rxn_dict[mol_cc] = -1\n",
    "            stoich_loop_dict[cid] = -1\n",
    "\n",
    "    for mol in right:\n",
    "        if type(mol) is dict:\n",
    "            cid = mol['Compound']['@frameid']\n",
    "            mol_cc = cc.get_compound(f\"metacyc.compound:{cid}\")\n",
    "            rxn_dict[mol_cc] =  1\n",
    "            stoich_loop_dict[cid] = 1\n",
    "    \n",
    "    rxns_dict[name] = Reaction(rxn_dict)\n",
    "    stoich_dict[name] = stoich_loop_dict\n",
    "    regulation_dict[name] = regulation_loop_dict\n",
    "    \n",
    "rxns_dict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "5e072326-7492-4a26-adba-02158fcedf0e",
   "metadata": {},
   "outputs": [],
   "source": [
    "(standard_dg_prime, dg_uncertainty) = cc.standard_dg_prime_multi(list(rxns_dict.values()), uncertainty_representation=\"cov\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "748784e9-37fa-4e06-8fa9-88b497816064",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([-21.05010908,  22.04792453,  -5.94611551,  -5.61774239]) <Unit('kilojoule / mole')>",
      "text/html": "<table><tbody><tr><th>Magnitude</th><td style='text-align:left;'><pre>[-21.05010908198642 22.047924530096907 -5.946115510564027<br> -5.617742386692498]</pre></td></tr><tr><th>Units</th><td style='text-align:left;'>kilojoule/mole</td></tr></tbody></table>",
      "text/latex": "$\\begin{pmatrix}-21.05010908198642 & 22.047924530096907 & -5.946115510564027 & -5.617742386692498\\end{pmatrix}\\ \\frac{\\mathrm{kilojoule}}{\\mathrm{mole}}$"
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "standard_dg_prime"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "11142f27-1260-4d21-97bc-42c00f4920f6",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([[ 1.53982130e+00, -2.21674712e+00,  6.54108560e-01,\n        -4.66426081e-03],\n       [-2.21674712e+00,  5.28694603e+00, -2.43228772e+00,\n        -1.29118274e-01],\n       [ 6.54108560e-01, -2.43228772e+00,  5.54727081e+00,\n        -8.89399854e-02],\n       [-4.66426081e-03, -1.29118274e-01, -8.89399854e-02,\n         3.01034610e-01]]) <Unit('kilojoule ** 2 / mole ** 2')>",
      "text/html": "<table><tbody><tr><th>Magnitude</th><td style='text-align:left;'><pre>[[1.5398212990074922 -2.2167471180569773 0.6541085596545129<br>  -0.004664260811860303]<br> [-2.2167471180569773 5.286946034707553 -2.4322877177623594<br>  -0.1291182736017488]<br> [0.6541085596545129 -2.4322877177623594 5.547270812427002<br>  -0.08893998540652082]<br> [-0.004664260811860303 -0.1291182736017488 -0.08893998540652082<br>  0.3010346102557717]]</pre></td></tr><tr><th>Units</th><td style='text-align:left;'>kilojoule<sup>2</sup>/mole<sup>2</sup></td></tr></tbody></table>",
      "text/latex": "$\\begin{pmatrix}1.5398212990074922 & -2.2167471180569773 & 0.6541085596545129 & -0.004664260811860303\\\\ \n-2.2167471180569773 & 5.286946034707553 & -2.4322877177623594 & -0.1291182736017488\\\\ \n0.6541085596545129 & -2.4322877177623594 & 5.547270812427002 & -0.08893998540652082\\\\ \n-0.004664260811860303 & -0.1291182736017488 & -0.08893998540652082 & 0.3010346102557717\\end{pmatrix}\\ \\frac{\\mathrm{kilojoule}^{2}}{\\mathrm{mole}^{2}}$"
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dg_uncertainty"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "320ca8b3-34c3-4bfe-b43b-e71e5d5685bc",
   "metadata": {},
   "outputs": [],
   "source": [
    "R = 0.008314 # kJ/mol*K\n",
    "T = 298.15 # K"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "6c217eee-8beb-4c13-82d5-200b12d4add9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([4.87556287e+03, 1.37137368e-04, 1.10096201e+01, 9.64363243e+00])"
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dG = standard_dg_prime._magnitude\n",
    "\n",
    "keq = np.exp(-dG/(R*T))\n",
    "keq"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3a19ac18-e8ce-4653-9976-3946c1227c85",
   "metadata": {
    "jp-MarkdownHeadingCollapsed": true,
    "tags": []
   },
   "source": [
    "# Calculating set of kinetic parameters with given equilibrium constants and arbitrary fluxes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "ad0c9880-fd76-40d6-9d15-3bb61f96e3e9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "                             6PFRUCTPHOS-RXN  F16ALDOLASE-RXN  2TRANSKETO-RXN  \\\nFRUCTOSE-6P                               -1                0               1   \nATP                                       -1                0               0   \nPROTON                                     1                0               0   \nADP                                        1                0               0   \nFRUCTOSE-16-DIPHOSPHATE                    1               -1               0   \nDIHYDROXY-ACETONE-PHOSPHATE                0                1               0   \nGAP                                        0                1               1   \nERYTHROSE-4P                               0                0              -1   \nXYLULOSE-5-PHOSPHATE                       0                0              -1   \n\n                             TRIOSEPISOMERIZATION-RXN  \nFRUCTOSE-6P                                         0  \nATP                                                 0  \nPROTON                                              0  \nADP                                                 0  \nFRUCTOSE-16-DIPHOSPHATE                             0  \nDIHYDROXY-ACETONE-PHOSPHATE                         1  \nGAP                                                -1  \nERYTHROSE-4P                                        0  \nXYLULOSE-5-PHOSPHATE                                0  ",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>6PFRUCTPHOS-RXN</th>\n      <th>F16ALDOLASE-RXN</th>\n      <th>2TRANSKETO-RXN</th>\n      <th>TRIOSEPISOMERIZATION-RXN</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>FRUCTOSE-6P</th>\n      <td>-1</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ATP</th>\n      <td>-1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>PROTON</th>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ADP</th>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>FRUCTOSE-16-DIPHOSPHATE</th>\n      <td>1</td>\n      <td>-1</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>DIHYDROXY-ACETONE-PHOSPHATE</th>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>GAP</th>\n      <td>0</td>\n      <td>1</td>\n      <td>1</td>\n      <td>-1</td>\n    </tr>\n    <tr>\n      <th>ERYTHROSE-4P</th>\n      <td>0</td>\n      <td>0</td>\n      <td>-1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>XYLULOSE-5-PHOSPHATE</th>\n      <td>0</td>\n      <td>0</td>\n      <td>-1</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Sd = pd.DataFrame(stoich_dict, dtype=np.int8).fillna(0).astype(np.int8)\n",
    "# Sd = Sd.iloc[0:7, 0:2]\n",
    "\n",
    "n_met = len(Sd.index)\n",
    "n_rxn = len(Sd.columns)\n",
    "\n",
    "Sd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "5c82bb78-fff2-4098-9827-6b0d10324746",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "          6PFRUCTPHOS-RXN  F16ALDOLASE-RXN  2TRANSKETO-RXN  \\\n$K_{eq}$         8.491991        -8.894527        2.398769   \n$v$            100.000000        20.000000       30.000000   \n\n          TRIOSEPISOMERIZATION-RXN  \n$K_{eq}$                  2.266298  \n$v$                      10.000000  ",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>6PFRUCTPHOS-RXN</th>\n      <th>F16ALDOLASE-RXN</th>\n      <th>2TRANSKETO-RXN</th>\n      <th>TRIOSEPISOMERIZATION-RXN</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>$K_{eq}$</th>\n      <td>8.491991</td>\n      <td>-8.894527</td>\n      <td>2.398769</td>\n      <td>2.266298</td>\n    </tr>\n    <tr>\n      <th>$v$</th>\n      <td>100.000000</td>\n      <td>20.000000</td>\n      <td>30.000000</td>\n      <td>10.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dG = standard_dg_prime._magnitude\n",
    "\n",
    "keq = np.exp(-dG/(R*T))\n",
    "keq\n",
    "\n",
    "K_eq = np.log(keq)\n",
    "vE = np.array([100, 20, 30, 10])\n",
    "\n",
    "K_eq[vE < 0] = 1/K_eq[vE < 0] \n",
    "\n",
    "lvE = np.log(np.abs(vE))\n",
    "\n",
    "pd.DataFrame(np.array([K_eq, vE]), columns=Sd.columns, index=[\"$K_{eq}$\", \"$v$\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "547db931-e727-4c7b-aa7f-a09b80fee71e",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([0, 1, 4, 6, 7, 8])"
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# set up variables\n",
    "\n",
    "S = np.array(Sd)\n",
    "S = np.multiply(S, vE/np.abs(vE)).astype(np.int8)\n",
    "S[S == -0] = 0\n",
    "S_s = -np.copy(S)\n",
    "S_p = np.copy(S) #reverse neg sign\n",
    "S_s[S > 0] = 0\n",
    "S_p[S < 0] = 0\n",
    "\n",
    "S_s_nz = np.array(S_s.nonzero())\n",
    "S_p_nz = np.array(S_p.nonzero())\n",
    "\n",
    "# first coordinate, e.g. metabolites w nonzero substrate/product coeff across all reactions. also works as substrate indices. \n",
    "met_s_nz = S_s_nz[0, :]\n",
    "met_p_nz = S_p_nz[0, :]\n",
    "\n",
    "# second coordinate, e.g. reactions indices for those concentrations. works to index substrates as well. \n",
    "rxn_s_nz = S_s_nz[1, :]   \n",
    "rxn_p_nz = S_p_nz[1, :]\n",
    "\n",
    "# one dim is always 2\n",
    "n_Km_s = np.max(met_s_nz.shape) \n",
    "n_Km_p = np.max(met_p_nz.shape)\n",
    "\n",
    "c = cp.Variable(n_met)\n",
    "Km_s = cp.Variable(n_Km_s)\n",
    "Km_p = cp.Variable(n_Km_p)\n",
    "\n",
    "cfwd = cp.Variable(n_rxn)\n",
    "crev = cp.Variable(n_rxn)\n",
    "\n",
    "# define Km positions by nonzero S matrix concentrations\n",
    "y_s = c[met_s_nz] - Km_s\n",
    "y_p = c[met_p_nz] - Km_p\n",
    "\n",
    "# index \n",
    "met_s_nz"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "e35cbcbb-7059-41e5-968a-d8997259e1d0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# number of saturation terms for sub, prod\n",
    "n_alpha = np.sum(np.power(2, S_s.sum(axis=0)) - 1)\n",
    "n_beta = np.sum(np.power(2, S_p.sum(axis=0)) - 1)\n",
    "\n",
    "# saturation matrix setup\n",
    "C_alpha = np.zeros([n_alpha, len(met_s_nz)])\n",
    "C_beta = np.zeros([n_beta, len(met_p_nz)])\n",
    "\n",
    "# to separate different reactions saturation terms. \n",
    "d_alpha = np.zeros(n_alpha, dtype=np.int8)\n",
    "d_beta = np.zeros(n_beta, dtype=np.int8)\n",
    "\n",
    "\n",
    "idx = 0\n",
    "\n",
    "for i in range(n_rxn):\n",
    "    \n",
    "    # pick one reaction at a time (get substrate indicies)\n",
    "    idx_cur_rxn = rxn_s_nz == i\n",
    "    \n",
    "    # generates all binary permutations minus the first one since that would result in -1\n",
    "    sat_perm = np.array(list(itertools.product([0, 1], repeat=sum(idx_cur_rxn))))\n",
    "    sat_perm = sat_perm[1:, :]\n",
    "    \n",
    "    r, _ = sat_perm.shape\n",
    "    \n",
    "    # replace zeros with saturation matrix\n",
    "    C_alpha[idx:(idx+r), idx_cur_rxn] = sat_perm\n",
    "    d_alpha[idx:(idx+r)] = i\n",
    "        \n",
    "    idx += r # add row # \n",
    "\n",
    "idx = 0\n",
    "    \n",
    "for i in range(n_rxn):\n",
    "    idx_cur_rxn = rxn_p_nz == i\n",
    "    \n",
    "    sat_perm = np.array(list(itertools.product([0, 1], repeat=sum(idx_cur_rxn))))\n",
    "    sat_perm = sat_perm[1:, :]\n",
    "    \n",
    "    r, _ = sat_perm.shape\n",
    "    \n",
    "    C_beta[idx:(idx+r), idx_cur_rxn] = sat_perm\n",
    "    d_beta[idx:(idx+r)] = i\n",
    "        \n",
    "    idx += r # add row # "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "e17e7a68-bcc4-4107-9abd-bc739f79b1ee",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([[0., 1., 0., 0., 0., 0.],\n       [1., 0., 0., 0., 0., 0.],\n       [1., 1., 0., 0., 0., 0.],\n       [0., 0., 1., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 1.],\n       [0., 0., 0., 0., 1., 0.],\n       [0., 0., 0., 0., 1., 1.],\n       [0., 0., 0., 1., 0., 0.]])"
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "C_alpha"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "9b1839b5-d544-44b6-96dc-3bbf1d217f35",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "[Expression(AFFINE, UNKNOWN, (12,)),\n Expression(AFFINE, UNKNOWN, (6,)),\n Expression(AFFINE, UNKNOWN, (8,)),\n Expression(AFFINE, UNKNOWN, (4,))]"
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "n_lse_terms = np.max(np.power(2, S_s.sum(axis=0)) +  np.power(2, S_p.sum(axis=0)) - 2)\n",
    "LSE_expr = []\n",
    "\n",
    "for i in range(n_rxn):\n",
    "    # sum terms are separate in logsumexp. one per saturation term (row in C_alpha, C_beta)\n",
    "    n_term_s = np.sum(d_alpha == i) \n",
    "    n_term_p = np.sum(d_beta == i)\n",
    "    n_term = n_term_s + n_term_p\n",
    "    \n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "    \n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "    \n",
    "    LSE_expr.append(cp.hstack( [ lvE[i] + (C_alpha @ y_s)[d_alpha == i] - cp.multiply(np.ones(n_term_s), -S.T[i, S_s_idx] @ y_s[Km_s_idx]) - cfwd[i],  \n",
    "                                 lvE[i] + (C_beta @ y_p)[d_beta == i] - cp.multiply(np.ones(n_term_p), -S.T[i, S_s_idx] @ y_s[Km_s_idx]) - cfwd[i],\n",
    "                                 lvE[i] + 0 - cp.multiply(np.ones(1), -S.T[i, S_s_idx] @ y_s[Km_s_idx])  - cfwd[i],\n",
    "                                 cp.multiply(np.ones(1), S.T[i, S_p_idx] @ y_p[Km_p_idx])  + crev[i]\n",
    "                                 - cp.multiply(np.ones(1), -S.T[i, S_s_idx] @ y_s[Km_s_idx])  - cfwd[i]\n",
    "                                 #-1*np.ones(n_lse_terms - n_term + 1) \n",
    "                               ]\n",
    "                             )\n",
    "                   )  # remove +1 here, could also have cfwd outside objec. \n",
    "    \n",
    "#LSE_expr = cp.vstack(LSE_expr)\n",
    "LSE_expr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "0ea14434-058e-444b-90e8-3d150362571f",
   "metadata": {},
   "outputs": [],
   "source": [
    "l = 0.0000001\n",
    "e = 0.00001\n",
    "f = 0.0000001\n",
    "reg =  cp.sum(cp.hstack([cfwd, crev, c])) + cp.sum(cp.hstack([-Km_s, -Km_p]))# regularization\n",
    "reg2 = cp.norm1(cp.hstack([cfwd, crev, c])) + cp.norm1(cp.hstack([-Km_s, -Km_p]))# regularization\n",
    "reg3 = cp.sum(cp.huber(cp.hstack([y_s, y_p]), 1))\n",
    "#reg3 = cp.norm1(cp.hstack([y_s, y_p])) # take a look at this\n",
    "\n",
    "loss = 0\n",
    "for i in range(n_rxn):\n",
    "    loss += cp.norm2(cp.pos(cp.log_sum_exp(LSE_expr[i])))\n",
    "loss += l * reg \n",
    "loss += e * reg2\n",
    "loss += f * reg3\n",
    "# "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "85586d27-113e-4b95-8d70-7dfd2abc644c",
   "metadata": {},
   "outputs": [],
   "source": [
    "haldane = []\n",
    "fwd_flux = []\n",
    "\n",
    "for i, r in enumerate(S.T):\n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "    \n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "    \n",
    "    haldane.append(K_eq[i] == cfwd[i] - crev[i] + r[S_p_idx] @ Km_p[Km_p_idx] - (-r[S_s_idx]) @ Km_s[Km_s_idx])  # add minus since s matrix has minus\n",
    "    fwd_flux.append(cfwd[i] + (-r[S_s_idx]) @ y_s[Km_s_idx] - (crev[i] + r[S_p_idx] @ y_p[Km_p_idx])  - (lvE[i])  >= 0)  # add minus since s matrix has minus"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "a77dbaef-1995-4496-a867-6891b901e35f",
   "metadata": {},
   "outputs": [],
   "source": [
    "constr = [cp.hstack([cfwd, crev, c, Km_s, Km_p]) >= -12,\n",
    "          cp.hstack([cfwd, crev, c, Km_s, Km_p]) <= 12, cfwd[0] == 7,\n",
    "          ]\n",
    "\n",
    "constr.extend(haldane)\n",
    "constr.extend(fwd_flux)\n",
    "constr.extend([S.T @ c <= K_eq])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "b434c2b0-a4d0-43f1-ad56-d98882abafa6",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "===============================================================================\n",
      "                                     CVXPY                                     \n",
      "                                     v1.3.0                                    \n",
      "===============================================================================\n",
      "(CVXPY) Apr 18 10:01:04 AM: Your problem has 31 variables, 12 constraints, and 0 parameters.\n",
      "(CVXPY) Apr 18 10:01:04 AM: It is compliant with the following grammars: DCP, DQCP\n",
      "(CVXPY) Apr 18 10:01:04 AM: (If you need to solve this problem multiple times, but with different data, consider using parameters.)\n",
      "(CVXPY) Apr 18 10:01:05 AM: CVXPY will first compile your problem; then, it will invoke a numerical solver to obtain a solution.\n",
      "-------------------------------------------------------------------------------\n",
      "                                  Compilation                                  \n",
      "-------------------------------------------------------------------------------\n",
      "(CVXPY) Apr 18 10:01:05 AM: Compiling problem (target solver=ECOS).\n",
      "(CVXPY) Apr 18 10:01:05 AM: Reduction chain: Dcp2Cone -> CvxAttr2Constr -> ConeMatrixStuffing -> ECOS\n",
      "(CVXPY) Apr 18 10:01:05 AM: Applying reduction Dcp2Cone\n",
      "(CVXPY) Apr 18 10:01:05 AM: Applying reduction CvxAttr2Constr\n",
      "(CVXPY) Apr 18 10:01:05 AM: Applying reduction ConeMatrixStuffing\n",
      "(CVXPY) Apr 18 10:01:05 AM: Applying reduction ECOS\n",
      "(CVXPY) Apr 18 10:01:05 AM: Finished problem compilation (took 6.106e-02 seconds).\n",
      "-------------------------------------------------------------------------------\n",
      "                                Numerical solver                               \n",
      "-------------------------------------------------------------------------------\n",
      "(CVXPY) Apr 18 10:01:05 AM: Invoking solver ECOS  to obtain a solution.\n",
      "-------------------------------------------------------------------------------\n",
      "                                    Summary                                    \n",
      "-------------------------------------------------------------------------------\n",
      "(CVXPY) Apr 18 10:01:05 AM: Problem status: optimal\n",
      "(CVXPY) Apr 18 10:01:05 AM: Optimal value: 4.814e-04\n",
      "(CVXPY) Apr 18 10:01:05 AM: Compilation took 6.106e-02 seconds\n",
      "(CVXPY) Apr 18 10:01:05 AM: Solver (including time spent in interface) took 2.683e-03 seconds\n"
     ]
    },
    {
     "data": {
      "text/plain": "0.0004813779651213706"
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "p = cp.Problem(cp.Minimize(loss), constr)\n",
    "p.solve(verbose=True, solver=cp.ECOS)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5b907a59-21fe-4dd1-9e19-fecf7bb1b1e5",
   "metadata": {
    "tags": []
   },
   "source": [
    "## Checking correctness of result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "168df7be-aa37-489b-96bd-70b211f45389",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([7.        , 3.25581073, 4.47957308, 2.99585499])"
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cfwd.value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "969fd0d0-cb84-4a85-abf9-8e45fac0190e",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([-1.92262961e-05,  5.59492674e+00,  2.08075612e+00,  4.27516090e-04])"
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "crev.value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "2c06bd43-858a-4a80-87b4-e906682ea9d2",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([ 2.22231156e-07,  8.03083688e-06, -3.83222023e-06, -3.83222023e-06,\n        2.19608329e+00, -9.69417048e+00, -1.59723269e-05,  7.35157061e-01,\n        7.35157061e-01])"
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "c.value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "41df70c2-16d4-4cb1-982c-24b36295a53b",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([-7.44709066e-01, -7.44465242e-01,  2.11470154e-05, -1.21641989e-08,\n        9.72160120e-07,  9.72160120e-07])"
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Km_s.value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "d2553824-cf7e-4608-9562-48bba6cc213c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([-2.27848459e-05,  4.67277371e-05,  4.67277371e-05,  2.70384610e-03,\n       -6.55534788e+00, -7.29129636e-01, -4.24039958e-05, -2.27853236e-05])"
     },
     "execution_count": 30,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Km_p.value"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2db77294-ce0c-4874-9ac5-954b940ac8d2",
   "metadata": {},
   "source": [
    "## Checking Haldane and fwd/rev flux ratios are satisfied"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "7bf9b6c8-032f-45db-a73c-188cfbb03736",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "haldane -1.9953816376983013e-10\n",
      "forward 6.295923461635894\n",
      "haldane 2.0899371122595767e-10\n",
      "forward 2.995742290234367\n",
      "haldane -5.63642466033798e-11\n",
      "forward 3.86909931448537\n",
      "haldane -5.325162533154071e-11\n",
      "forward 11.960452349894126\n"
     ]
    }
   ],
   "source": [
    "for i, r in enumerate(S.T):\n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "    \n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "    \n",
    "    print(\"haldane\", cfwd.value[i] - crev.value[i] + r[S_p_idx] @ Km_p.value[Km_p_idx] - (-r[S_s_idx]) @ Km_s.value[Km_s_idx] - K_eq[i] )\n",
    "    # print(cfwd.value[i], (-r[S_s_idx]), y_s.value[Km_s_idx], crev.value[i], r[S_p_idx],  y_p.value[Km_p_idx])\n",
    "    print(\"forward\", cfwd.value[i] + (-r[S_s_idx]) @ y_s.value[Km_s_idx] - (crev.value[i] + r[S_p_idx] @ y_p.value[Km_p_idx]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "7dc38b25-e201-4b6b-a275-25561489b194",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([ 7.44709289e-01,  7.44473273e-01,  2.19606214e+00, -1.59601627e-05,\n        7.35156089e-01,  7.35156089e-01])"
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "y_s.value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "7d6bf207-f672-4a6f-a191-cc6f0eb648f6",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([ 2.30070771e-05, -5.05599573e-05, -5.05599573e-05,  2.19337945e+00,\n       -3.13882259e+00, -8.96504084e+00,  2.64316689e-05,  6.81299667e-06])"
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "y_p.value"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6bc8db34-d4c9-4790-bebb-9dbcaa4bb578",
   "metadata": {},
   "source": [
    "## Checking that objective has been minimized."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "63d99f85-252b-4b52-8f21-383c88191a6f",
   "metadata": {},
   "source": [
    "Need to rearrange terms."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "b3655804-a36b-45ea-a80d-275306b72dfe",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 84.60045977  10.25668824  18.68741751   9.99986912]\n",
      " [100.          20.          30.          10.        ]]\n"
     ]
    }
   ],
   "source": [
    "LSE_expr = []\n",
    "\n",
    "for i in range(n_rxn):\n",
    "    # sum terms are separate in logsumexp. one per saturation term (row in C_alpha, C_beta)\n",
    "    n_term_s = np.sum(d_alpha == i) \n",
    "    n_term_p = np.sum(d_beta == i)\n",
    "    n_term = n_term_s + n_term_p\n",
    "    \n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "    \n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "    \n",
    "    \n",
    "    LSE_expr.append(           [ (C_alpha @ y_s.value)[d_alpha == i] - np.multiply(np.ones(n_term_s), -S.T[i, S_s_idx] @ y_s.value[Km_s_idx]) - cfwd.value[i],  \n",
    "                                 (C_beta @ y_p.value)[d_beta == i] - np.multiply(np.ones(n_term_p), -S.T[i, S_s_idx] @ y_s.value[Km_s_idx]) - cfwd.value[i],\n",
    "                                 0 - np.multiply(np.ones(1), -S.T[i, S_s_idx] @ y_s.value[Km_s_idx])  - cfwd.value[i],\n",
    "                                 np.multiply(np.ones(1), S.T[i, S_p_idx] @ y_p.value[Km_p_idx])  + crev.value[i]\n",
    "                                 - np.multiply(np.ones(1), -S.T[i, S_s_idx] @ y_s.value[Km_s_idx])  - cfwd.value[i]\n",
    "                                 #-1*np.ones(n_lse_terms - n_term + 1) \n",
    "                                 #-1*np.ones(n_lse_terms - n_term + 1) \n",
    "                               ]\n",
    "                   )\n",
    "    \n",
    "\n",
    "est = np.zeros(4)    \n",
    "\n",
    "for i, rxn in enumerate(LSE_expr):\n",
    "    s = 0\n",
    "    \n",
    "    for term in rxn:\n",
    "        s += np.sum(np.exp(term))\n",
    "        \n",
    "    est[i] = np.log(s)\n",
    "    \n",
    "\n",
    "# est is obj. \n",
    "print(np.array([np.exp(-est),np.exp(lvE)]))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d282711e-4f51-401b-b575-0e1ba82d7150",
   "metadata": {},
   "source": [
    "## How closely does the objective match our target kcats?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "b87caa09-14b9-44b4-b4da-647b62e5f898",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 84.60045977  10.25668824  18.68741751   9.99986912]\n",
      " [100.          20.          30.          10.        ]]\n"
     ]
    }
   ],
   "source": [
    "print(np.array([np.exp(-est),np.exp(lvE)]))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "88c231fb-31bf-4347-ad2d-8b9495c745d9",
   "metadata": {},
   "source": [
    "Remarkable. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "87868215-a91b-442e-b3f3-13121677d5f0",
   "metadata": {
    "tags": []
   },
   "source": [
    "## What do fluxes with reverse flow look like?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 250,
   "id": "f148ad8b-a086-440b-9cf3-304bc244e77b",
   "metadata": {},
   "outputs": [],
   "source": [
    "sat_expr = []\n",
    "fwd_sat = np.zeros(n_rxn)\n",
    "back_sat = np.zeros(n_rxn)\n",
    "sat = np.zeros(n_rxn)\n",
    "\n",
    "for i in range(n_rxn):\n",
    "    # sum terms are separate in logsumexp. one per saturation term (row in C_alpha, C_beta)\n",
    "    n_term_s = np.sum(d_alpha == i) \n",
    "    n_term_p = np.sum(d_beta == i)\n",
    "    n_term = n_term_s + n_term_p\n",
    "    \n",
    "    \n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "    \n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "    \n",
    "    #S_s_idx = S_s_nz[0, S_s_nz[1, :] == i]\n",
    "    \n",
    "    sat_expr.append(           [ (C_alpha @ y_s.value)[d_alpha == i] ,  \n",
    "                                 (C_beta @ y_p.value)[d_beta == i],\n",
    "                                 0,\n",
    "                                 #-1*np.ones(n_lse_terms - n_term + 1) \n",
    "                               ]\n",
    "                   )\n",
    "    fwd_sat[i] = (np.exp(-S.T[i, S_s_idx] @ y_s.value[Km_s_idx])) # + cfwd.value[i]\n",
    "    back_sat[i] = (np.exp(S.T[i, S_p_idx] @ y_p.value[Km_p_idx])) # + cfwd.value[i]\n",
    "    \n",
    "    \n",
    "\n",
    "for i, rxn in enumerate(sat_expr):\n",
    "    s = 0\n",
    "    \n",
    "    for term in rxn:\n",
    "        s += np.sum(np.exp(term))\n",
    "        \n",
    "    sat[i] = (s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 251,
   "id": "2ec2a988-ad4a-45a1-afda-4006da2b2264",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([0.09140335, 0.81160617, 0.34742853, 0.49996406])"
     },
     "execution_count": 251,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "fwd_sat/sat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 252,
   "id": "52799b3c-90c6-49b3-b13b-ccf121d34636",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([1.84819175e-01, 3.91242311e-03, 7.98601209e-02, 6.38966298e-05])"
     },
     "execution_count": 252,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "back_sat/sat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 253,
   "id": "01dc4162-6b77-4dd2-9bef-333d4f05aed6",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([100.23594632,  21.05358085,  30.64215805,  10.00050835])"
     },
     "execution_count": 253,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.exp(cfwd.value) * fwd_sat/sat "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 254,
   "id": "a721b1a5-a03f-4cb7-a96a-1959c053bf39",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([100.05113069,  20.00091235,  30.00243667,  10.00044442])"
     },
     "execution_count": 254,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.exp(cfwd.value) * fwd_sat/sat - np.exp(crev.value) * back_sat/sat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 255,
   "id": "e606bbac-e82b-4853-a474-d6dde1be1ac5",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([1.84815621e-01, 1.05266850e+00, 6.39721381e-01, 6.39239525e-05])"
     },
     "execution_count": 255,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.exp(crev.value) * back_sat/sat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 256,
   "id": "6bcd27a4-3909-4845-b18a-ddcd03197ca7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Substrate Km: ['0.475', '0.475', '1.000', '1.000', '1.000', '1.000']\n",
      "Product Km: ['1.000', '1.000', '1.000', '1.003', '0.001', '0.482', '1.000', '1.000']\n",
      "Fwd kcat: ['1096.633', '25.941', '88.197', '20.002']\n",
      "Rev kcat: ['1.000', '269.058', '8.011', '1.000']\n",
      "Concentrations: ['1.000', '1.000', '1.000', '1.000', '8.990', '0.000', '1.000', '2.086', '2.086']\n"
     ]
    }
   ],
   "source": [
    "print('Substrate Km:', [f'{val:.3f}' for val in np.exp(Km_s.value)])\n",
    "print('Product Km:', [f'{val:.3f}' for val in np.exp(Km_p.value)])\n",
    "print('Fwd kcat:', [f'{val:.3f}' for val in np.exp(cfwd.value)])\n",
    "print('Rev kcat:', [f'{val:.3f}' for val in np.exp(crev.value)])\n",
    "print('Concentrations:', [f'{val:.3f}' for val in np.exp(c.value)])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 257,
   "id": "760251b4-5b1d-47dc-8255-acacc9120c71",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "                   Reaction          variable       value\n0           6PFRUCTPHOS-RXN       True fluxes  100.000000\n1           F16ALDOLASE-RXN       True fluxes   20.000000\n2            2TRANSKETO-RXN       True fluxes   30.000000\n3  TRIOSEPISOMERIZATION-RXN       True fluxes   10.000000\n4           6PFRUCTPHOS-RXN  Estimated fluxes  100.051131\n5           F16ALDOLASE-RXN  Estimated fluxes   20.000912\n6            2TRANSKETO-RXN  Estimated fluxes   30.002437\n7  TRIOSEPISOMERIZATION-RXN  Estimated fluxes   10.000444",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Reaction</th>\n      <th>variable</th>\n      <th>value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>True fluxes</td>\n      <td>100.000000</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>F16ALDOLASE-RXN</td>\n      <td>True fluxes</td>\n      <td>20.000000</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2TRANSKETO-RXN</td>\n      <td>True fluxes</td>\n      <td>30.000000</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>True fluxes</td>\n      <td>10.000000</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>Estimated fluxes</td>\n      <td>100.051131</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>F16ALDOLASE-RXN</td>\n      <td>Estimated fluxes</td>\n      <td>20.000912</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>2TRANSKETO-RXN</td>\n      <td>Estimated fluxes</td>\n      <td>30.002437</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>Estimated fluxes</td>\n      <td>10.000444</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 257,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reconst_df = pd.DataFrame({\"Reaction\": Sd.columns, \"True fluxes\": np.abs(vE), \"Estimated fluxes\": np.exp(cfwd.value) * fwd_sat/sat - np.exp(crev.value) * back_sat/sat})\n",
    "reconst_df = reconst_df.melt(id_vars=\"Reaction\")\n",
    "reconst_df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 258,
   "id": "ccb402e5-4c55-4e57-8b6c-6c6eb77452d8",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "<Figure size 1080.78x360 with 1 Axes>",
      "image/png": "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RERE5BUpgReRt+b0iQspHYI8J3/BnKRJmyqlwxARERGRV6QEXkTeiqjIKLz6zE7pMOQ5Y0O6UbzUxykdhoiIiIi8Is2BFxERERERETEDSuBFREREREREzIASeBEREREREREzoAReRERERERExAwogRcRERERERExA0rgRURERERERMyAEngRERERERERM6AEXkRERERERMQMKIEXERERERERMQNK4EVERERERETMgBJ4ERERERERETOgBF5ERERERETEDCiBFxERERERETEDSuBFREREREREzIASeBEREREREREzoAReRERERERExAwogRcRERERERExA0rgRURERERERMyAEngRERERERERM6AEXkRERERERMQMKIF/zwwbNgwnJ6d4vw4ePGhS/9SpUxQvXpzr16/Hauv06dN89dVXuLi4UKFCBQYPHsyNGzfiPO7SpUtxcnLC09Mzzu0hISEUK1YswdhDQ0Njxevs7Ez16tUJCAggPDw8zv0uXLiAj48P7u7ulChRgipVqtC3b1+OHj0aq27btm3p0KFDgnE8Lzg4GCcnJyZMmBBvnStXrjB8+HCqVq1KiRIl+PTTT+nevTtHjhwxqRcSEpJg3zg7OycYy+XLl+Pcr0SJElSqVInevXtz/vx5Y/1x48bh5OTE9u3bY7V148YNKleuTNeuXTEYDBw+fBgnJyf69u0b57FnzJiBk5NTgvGJiIiIiEjysk7pACTpOTg4MGXKlDi3FSxY0Pj9X3/9Rbdu3YiIiIhV79KlS7Ru3ZqiRYsyefJkbt++zYQJE+jVqxerVq2KVT80NJTChQuzbds2wsPDyZw582vHP3PmTDJnzozBYODRo0ecOHGCuXPn8sMPP7By5UqTtvfu3Uu/fv3InTs33bt3J1++fPz33398++23tGnThgEDBtC1a9fXiiMiIoINGzZQuHBhQkND6du3LzY2NiZ1/vnnH5o3b07OnDkZOHAgDg4OhIeHs3r1atq3b8+UKVOoWbOmsb6VlRXLly+P83iWlq92P61Pnz5UrlzZ+DnmGs2aNYtOnTqxZcsW7Ozs6N+/P/v378fX15fSpUuTLVs2AKKiohg0aBAWFhYEBQVhYWFhbGvr1q1s27bNJGYREREREXk3KIF/D9na2lK6dOl4t0dERLBq1SomTJgQKyGNMW3aNDJnzsy8efOws7MDIF26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hAULFhAREUH+/PkJCgqicePGb3aR3lOJfg88wA8//MC+fft4+PAhUVFRxvLIyEgePHjA0aNHOXToUJIGKiLmLTIikobVvFI6DHkPjQ3phlPxvO/Fu6D1Xut3k/rl3aR+eTfpPfAiySvRT+C//fZbfHx8jCsKWlhYmLySwNbWVnPgRURERERERJJYohexW7x4Mblz52bz5s1s2LABg8HA3r17+eGHH/jqq6+IiIigVatWyRGriIiIiIiIyAcr0Qn833//TbNmzcifPz+FCxcmbdq0/PTTT2TPnp3BgwdTqVIl5syZkxyxioiIiIiIiHywEp3AW1hYmKwGmDdvXv7880/jZzc3N86cOZM00YmIiIiIiIgI8BoJfN68eU0S9Hz58nHq1Cnj54iIiES/okBEREREREREEpboBL5OnTosX76cSZMm8eTJEypVqsThw4cJCwvj2LFjLFu2jPz58ydHrCIiIiIiIiIfrEQn8F999RW1atVi7ty5REVF0bBhQ5ycnPDy8qJFixZcuXKFPn36JEesIiIiIiIiIh+sRL9GztramvHjxzNs2DBSp45+z+OKFSvYtGkTt2/fplKlShQqVCjJAxURERERERH5kCU6gY+RNWtWoqKiCA8PJ3369DRq1CgJwxIRERERERGR5yV6CD3AhQsX6NOnD66urlSpUoWjR4/y448/0qxZM37++eekjlFERERERETkg/fa74E/cuQIn332GQaDAQArKyvOnTtHp06d+O2335I6ThEREREREZEPWqKH0E+cOJFUqVIRFhaGhYUF27ZtA6BcuXJs2rSJli1bMm3aNObNm5fkwYqIiIiIiLyK+/cecf7s1RQ7fv6CObFPlzrR+w0bNoywsLAE65QrV44lS5a8bmiv7f79+wwZMoQDBw5ga2vLsGHD8Pb2ZtmyZZQtW/atx/MhSnQCf+jQITp27EiWLFm4deuWybYcOXLQqlUrJe8iIiIiIpKizp+9ilef2Sl2/LEh3XB2KZDo/Xr27MmXX35p/Dxq1CisrKzw8fExltnb2ydJjIm1ceNGdu7cyYgRIyhUqBCRkZEpEseHLNEJ/NOnT0mfPn28221sbHjy5MkbBSUiIiIiIvIhypMnD3ny5DF+tre3x8rKitKlS6dcUP/f7du3AWjVqhUWFhYcPnw4ZQP6ACV6DnyRIkXYtWtXnNsiIiLYsGED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1K9fH4Dbt28DULBgQZP6q1ev5tGjR0RERMTbZtasWTl//jyPHz82lu3atYsnT54YP5coUYJs2bKxZMkSHjx4YCy/f/8+/fv3x8vLCysrq6Q4RRERkXeCnsCLiIjIG/noo4/45JNP2L17N6VLlzY+IXdxccHe3p6xY8dy5coVMmTIwOHDh9m0aRN2dnYmSfeL6tWrx+jRo+ncuTMNGjTgwoULrF692vjUHaLn1/v4+DBgwAA8PDxo2rQpdnZ2rFmzhqtXrzJ+/HisrfVfHREReX/ot5qIiIi8sfr163PkyBHj4nUQ/RR9zpw5jB8/npkzZ2Jra0v+/PmZOHEix44dY/Hixdy4cYOsWbPGaq9Vq1bcvn2btWvXMnr0aIoUKcK0adOYP3++yer1tWrVIkOGDMycOZMZM2ZgaWlJoUKFmDlzJm5ubm/l3EVERN4WC8ObLgErIiIiIiIiIslOc+BFREREREREzIASeBEREREREREzoAReRERERERExAwogRcRERERERExA0rgRURERERERMyAEngRERERERERM6AEXkRERERERMQMKIEXERERERERMQNK4EVERERERETMgBJ4ERERERERETPw/wAulPl+cAm9EwAAAABJRU5ErkJggg==\n"
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "sns.catplot(y=\"Reaction\", hue=\"variable\", x=\"value\", data=reconst_df, kind=\"bar\", aspect=2.5)\n",
    "plt.savefig(\"notebooks/fbagd/figures/reconstruction.png\", dpi=300)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 259,
   "id": "3ffdf47a-d0f6-4e70-83c5-f46f50562a94",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([100.05113069,  20.00091235,  30.00243667,  10.00044442])"
     },
     "execution_count": 259,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.exp(cfwd.value) * fwd_sat/sat - np.exp(crev.value) * back_sat/sat"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6f40a66b-cdad-426d-9584-22647d984c5b",
   "metadata": {
    "jp-MarkdownHeadingCollapsed": true,
    "tags": []
   },
   "source": [
    "# Including inhibition"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "af4bef04-60ec-4e63-af96-b1db319e0a3c",
   "metadata": {},
   "source": [
    "## I'm excluding some of the first operations as they are the same. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 260,
   "id": "7e6459f6-81f0-4ac0-ac67-fcfe43974a38",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "          6PFRUCTPHOS-RXN  F16ALDOLASE-RXN  2TRANSKETO-RXN  \\\n$K_{eq}$         8.491991         8.894527        2.398769   \n$v$            100.000000       -20.000000       30.000000   \n\n          TRIOSEPISOMERIZATION-RXN  \n$K_{eq}$                  2.266298  \n$v$                      10.000000  ",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>6PFRUCTPHOS-RXN</th>\n      <th>F16ALDOLASE-RXN</th>\n      <th>2TRANSKETO-RXN</th>\n      <th>TRIOSEPISOMERIZATION-RXN</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>$K_{eq}$</th>\n      <td>8.491991</td>\n      <td>8.894527</td>\n      <td>2.398769</td>\n      <td>2.266298</td>\n    </tr>\n    <tr>\n      <th>$v$</th>\n      <td>100.000000</td>\n      <td>-20.000000</td>\n      <td>30.000000</td>\n      <td>10.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 260,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dG = standard_dg_prime._magnitude\n",
    "\n",
    "keq = np.exp(-dG/(R*T))\n",
    "keq\n",
    "\n",
    "K_eq = np.log(keq)\n",
    "vE = np.array([100, -20, 30, 10])\n",
    "\n",
    "K_eq[vE < 0] = -K_eq[vE < 0] \n",
    "\n",
    "lvE = np.log(np.abs(vE))\n",
    "\n",
    "pd.DataFrame(np.array([K_eq, vE]), columns=Sd.columns, index=[\"$K_{eq}$\", \"$v$\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 261,
   "id": "f76ea927-4576-4eb5-b24e-c3dcdc934ff2",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": "                             6PFRUCTPHOS-RXN  F16ALDOLASE-RXN  2TRANSKETO-RXN  \\\nFRUCTOSE-6P                               -1                0               1   \nATP                                       -1                0               0   \nPROTON                                     1                0               0   \nADP                                        1                0               0   \nFRUCTOSE-16-DIPHOSPHATE                    1               -1               0   \nDIHYDROXY-ACETONE-PHOSPHATE                0                1               0   \nGAP                                        0                1               1   \nERYTHROSE-4P                               0                0              -1   \nXYLULOSE-5-PHOSPHATE                       0                0              -1   \n\n                             TRIOSEPISOMERIZATION-RXN  \nFRUCTOSE-6P                                         0  \nATP                                                 0  \nPROTON                                              0  \nADP                                                 0  \nFRUCTOSE-16-DIPHOSPHATE                             0  \nDIHYDROXY-ACETONE-PHOSPHATE                         1  \nGAP                                                -1  \nERYTHROSE-4P                                        0  \nXYLULOSE-5-PHOSPHATE                                0  ",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>6PFRUCTPHOS-RXN</th>\n      <th>F16ALDOLASE-RXN</th>\n      <th>2TRANSKETO-RXN</th>\n      <th>TRIOSEPISOMERIZATION-RXN</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>FRUCTOSE-6P</th>\n      <td>-1</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ATP</th>\n      <td>-1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>PROTON</th>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ADP</th>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>FRUCTOSE-16-DIPHOSPHATE</th>\n      <td>1</td>\n      <td>-1</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>DIHYDROXY-ACETONE-PHOSPHATE</th>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>GAP</th>\n      <td>0</td>\n      <td>1</td>\n      <td>1</td>\n      <td>-1</td>\n    </tr>\n    <tr>\n      <th>ERYTHROSE-4P</th>\n      <td>0</td>\n      <td>0</td>\n      <td>-1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>XYLULOSE-5-PHOSPHATE</th>\n      <td>0</td>\n      <td>0</td>\n      <td>-1</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 261,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Sd"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "59f138a7-df55-4436-8c87-9e799036d0e0",
   "metadata": {},
   "source": [
    "Adding regulation dict."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 262,
   "id": "760bee51-984c-4f98-91fd-788113ce0d86",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "                             6PFRUCTPHOS-RXN  F16ALDOLASE-RXN  2TRANSKETO-RXN  \\\nFRUCTOSE-6P                                1                0               0   \nATP                                        0                0               0   \nPROTON                                     0                0               0   \nADP                                        1                0               0   \nFRUCTOSE-16-DIPHOSPHATE                    0                0               0   \nDIHYDROXY-ACETONE-PHOSPHATE                0                0               0   \nGAP                                        0                0               0   \nERYTHROSE-4P                               0                0               0   \nXYLULOSE-5-PHOSPHATE                       0                0               0   \n\n                             TRIOSEPISOMERIZATION-RXN  \nFRUCTOSE-6P                                         0  \nATP                                                 0  \nPROTON                                              0  \nADP                                                 0  \nFRUCTOSE-16-DIPHOSPHATE                             0  \nDIHYDROXY-ACETONE-PHOSPHATE                         0  \nGAP                                                 0  \nERYTHROSE-4P                                        0  \nXYLULOSE-5-PHOSPHATE                                0  ",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>6PFRUCTPHOS-RXN</th>\n      <th>F16ALDOLASE-RXN</th>\n      <th>2TRANSKETO-RXN</th>\n      <th>TRIOSEPISOMERIZATION-RXN</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>FRUCTOSE-6P</th>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ATP</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>PROTON</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ADP</th>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>FRUCTOSE-16-DIPHOSPHATE</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>DIHYDROXY-ACETONE-PHOSPHATE</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>GAP</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ERYTHROSE-4P</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>XYLULOSE-5-PHOSPHATE</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 262,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Sr_min = pd.DataFrame(regulation_dict).fillna(0).astype(np.int8)\n",
    "\n",
    "Sr = Sd.copy()\n",
    "Sr.loc[:,:] = 0\n",
    "Sr.loc[Sd.index.intersection(Sr_min.index), :] = Sr_min.loc[Sd.index.intersection(Sr_min.index), :]\n",
    "Sr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 263,
   "id": "5bf8a342-931a-45a0-b57b-d4f0c50c4e20",
   "metadata": {},
   "outputs": [],
   "source": [
    "# set up variables\n",
    "\n",
    "S = np.array(Sd)\n",
    "S = np.multiply(S, vE/np.abs(vE)).astype(np.int8)\n",
    "S[S == -0] = 0\n",
    "S_s = -np.copy(S)\n",
    "S_p = np.copy(S) #reverse neg sign\n",
    "S_s[S > 0] = 0\n",
    "S_p[S < 0] = 0\n",
    "S_i = np.copy(np.array(Sr) == -1)\n",
    "S_a = np.copy(np.array(Sr) == 1)\n",
    "\n",
    "\n",
    "S_s_nz = np.array(S_s.nonzero())\n",
    "S_p_nz = np.array(S_p.nonzero())\n",
    "S_i_nz = np.array(S_i.nonzero())\n",
    "S_a_nz = np.array(S_a.nonzero())\n",
    "\n",
    "# TODO Refactor all the below lines as one liners \n",
    "# first coordinate, e.g. metabolites w nonzero substrate/product coeff across all reactions. also works as substrate indices. \n",
    "met_s_nz = S_s_nz[0, :]\n",
    "met_p_nz = S_p_nz[0, :]\n",
    "met_i_nz = S_i_nz[0, :]\n",
    "met_a_nz = S_a_nz[0, :]\n",
    "\n",
    "# second coordinate, e.g. reactions indices for those concentrations. works to index substrates as well. \n",
    "rxn_s_nz = S_s_nz[1, :]   \n",
    "rxn_p_nz = S_p_nz[1, :]\n",
    "rxn_i_nz = S_i_nz[1, :]\n",
    "rxn_a_nz = S_a_nz[1, :]\n",
    "\n",
    "# one dim is always 2\n",
    "n_Km_s = np.max(met_s_nz.shape) \n",
    "n_Km_p = np.max(met_p_nz.shape)\n",
    "n_Km_i = np.max(met_i_nz.shape) \n",
    "n_Km_a = np.max(met_a_nz.shape)\n",
    "\n",
    "c = cp.Variable(n_met)\n",
    "Km_s = cp.Variable(n_Km_s)\n",
    "Km_p = cp.Variable(n_Km_p)\n",
    "Km_i = cp.Variable(n_Km_i) if n_Km_i else None\n",
    "Km_a = cp.Variable(n_Km_a) if n_Km_a else None\n",
    "\n",
    "cfwd = cp.Variable(n_rxn)\n",
    "crev = cp.Variable(n_rxn)\n",
    "\n",
    "# define Km positions by nonzero S matrix concentrations. Activation is reverse val of inhibition. \n",
    "y_s = c[met_s_nz] - Km_s\n",
    "y_p = c[met_p_nz] - Km_p\n",
    "y_i = c[met_i_nz] - Km_i if n_Km_i else None\n",
    "y_a = -(c[met_a_nz] - Km_a) if n_Km_a else None\n",
    "\n",
    "# saturation stacks\n",
    "if n_Km_i and n_Km_a:\n",
    "    y_f = cp.hstack((y_s, y_i, y_a))\n",
    "    y_r = cp.hstack((y_p, y_i, y_a))\n",
    "elif n_Km_i:\n",
    "    y_f = cp.hstack((y_s, y_i))\n",
    "    y_r = cp.hstack((y_p, y_i))\n",
    "elif n_Km_a:\n",
    "    y_f = cp.hstack((y_s, y_a))\n",
    "    y_r = cp.hstack((y_p, y_a))\n",
    "else:\n",
    "    y_f = y_s\n",
    "    y_r = y_p"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 264,
   "id": "627f247b-9c2f-4648-8798-4703fbc261e8",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([[-1,  0,  1,  0],\n       [-1,  0,  0,  0],\n       [ 1,  0,  0,  0],\n       [ 1,  0,  0,  0],\n       [ 1,  1,  0,  0],\n       [ 0, -1,  0,  1],\n       [ 0, -1,  1, -1],\n       [ 0,  0, -1,  0],\n       [ 0,  0, -1,  0]], dtype=int8)"
     },
     "execution_count": 264,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "S"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 265,
   "id": "7e415219-5e67-4cbd-9e87-f7c858c1a648",
   "metadata": {},
   "outputs": [],
   "source": [
    "# number of saturation terms for sub, prod\n",
    "S_s_comb = np.concatenate((S_s, S_i, S_a), axis=0)\n",
    "S_p_comb = np.concatenate((S_p, S_i, S_a), axis=0)\n",
    "n_alpha = np.sum(np.power(2, S_s_comb.sum(axis=0)) - 1)\n",
    "n_beta = np.sum(np.power(2, S_p_comb.sum(axis=0)) - 1)\n",
    "\n",
    "# saturation matrix setup, first sub, then inhib, then act. \n",
    "C_alpha = np.zeros([n_alpha, len(met_s_nz) + len(met_i_nz) + len(met_a_nz)])\n",
    "C_beta = np.zeros([n_beta, len(met_p_nz) + len(met_i_nz) + len(met_a_nz)])\n",
    "\n",
    "# to separate different reactions saturation terms to their individual reaction equations. \n",
    "d_alpha = np.zeros(n_alpha, dtype=np.int8)\n",
    "d_beta = np.zeros(n_beta, dtype=np.int8)\n",
    "\n",
    "\n",
    "idx = 0\n",
    "\n",
    "for i in range(n_rxn):\n",
    "    \n",
    "    # pick one reaction at a time (get substrate indicies)\n",
    "    #idx_cur_rxn = rxn_s_nz == i\n",
    "    idx_cur_rxn = np.concatenate((rxn_s_nz == i, rxn_i_nz == i, rxn_a_nz == i))\n",
    "    \n",
    "    # generates all binary permutations minus the first one since that would result in -1\n",
    "    sat_perm = np.array(list(itertools.product([0, 1], repeat=sum(idx_cur_rxn))))\n",
    "    sat_perm = sat_perm[1:, :]\n",
    "    \n",
    "    r, _ = sat_perm.shape\n",
    "    \n",
    "    # replace zeros with saturation matrix\n",
    "    C_alpha[idx:(idx+r), idx_cur_rxn] = sat_perm\n",
    "    d_alpha[idx:(idx+r)] = i\n",
    "        \n",
    "    idx += r # add row # \n",
    "\n",
    "idx = 0\n",
    "    \n",
    "for i in range(n_rxn):\n",
    "    idx_cur_rxn = np.concatenate((rxn_p_nz == i, rxn_i_nz == i, rxn_a_nz == i))\n",
    "    \n",
    "    sat_perm = np.array(list(itertools.product([0, 1], repeat=sum(idx_cur_rxn))))\n",
    "    sat_perm = sat_perm[1:, :]\n",
    "    \n",
    "    r, _ = sat_perm.shape\n",
    "    \n",
    "    C_beta[idx:(idx+r), idx_cur_rxn] = sat_perm\n",
    "    d_beta[idx:(idx+r)] = i\n",
    "        \n",
    "    idx += r # add row # "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 266,
   "id": "be7e4a69-a3da-4811-b363-bd748ea66e3c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "[Expression(AFFINE, UNKNOWN, (48,)),\n Expression(AFFINE, UNKNOWN, (6,)),\n Expression(AFFINE, UNKNOWN, (8,)),\n Expression(AFFINE, UNKNOWN, (4,))]"
     },
     "execution_count": 266,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "n_lse_terms = np.max(np.power(2, S_s.sum(axis=0)) +  np.power(2, S_p.sum(axis=0)) - 2)\n",
    "LSE_expr = []\n",
    "\n",
    "for i in range(n_rxn):\n",
    "    # sum terms are separate in logsumexp. one per saturation term (row in C_alpha, C_beta)\n",
    "    n_term_s = np.sum(d_alpha == i) \n",
    "    n_term_p = np.sum(d_beta == i)\n",
    "    n_term = n_term_s + n_term_p\n",
    "    \n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "    \n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "    \n",
    "    LSE_expr.append(cp.hstack( [ lvE[i] + (C_alpha @ y_f)[d_alpha == i] - cp.multiply(np.ones(n_term_s), - S.T[i, S_s_idx] @ y_s[Km_s_idx]) - cfwd[i],  \n",
    "                                 lvE[i] + (C_beta @ y_r)[d_beta == i] - cp.multiply(np.ones(n_term_p), - S.T[i, S_s_idx] @ y_s[Km_s_idx]) - cfwd[i],\n",
    "                                 lvE[i] + 0 - cp.multiply(np.ones(1), -S.T[i, S_s_idx] @ y_s[Km_s_idx])  - cfwd[i],\n",
    "                                 cp.multiply(np.ones(1), S.T[i, S_p_idx] @ y_p[Km_p_idx])  + crev[i]\n",
    "                                 - cp.multiply(np.ones(1), -S.T[i, S_s_idx] @ y_s[Km_s_idx])  - cfwd[i]\n",
    "                                 #-1*np.ones(n_lse_terms - n_term + 1) \n",
    "                               ]\n",
    "                             )\n",
    "                   )  # remove +1 here, could also have cfwd outside objec. \n",
    "    \n",
    "#LSE_expr = cp.vstack(LSE_expr)\n",
    "LSE_expr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 267,
   "id": "659d1c8d-3aef-4b75-a77e-76efc4d006a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "l = 0.0000001\n",
    "e = 0.00001\n",
    "f = 0.0000001\n",
    "reg =  cp.sum(cp.hstack([cfwd, crev, c])) + cp.sum(cp.hstack([-Km_s, -Km_p]))# regularization\n",
    "reg2 = cp.norm1(cp.hstack([cfwd, crev, c])) + cp.norm1(cp.hstack([-Km_s, -Km_p]))# regularization\n",
    "reg3 = cp.sum(cp.huber(cp.hstack([y_s, y_p]), 1))\n",
    "\n",
    "if n_Km_i:\n",
    "    reg += cp.sum(cp.hstack([-Km_i]))\n",
    "if n_Km_a:\n",
    "    reg += cp.sum(cp.hstack([-Km_a]))\n",
    "#reg3 = cp.norm1(cp.hstack([y_s, y_p])) # take a look at this\n",
    "\n",
    "loss = 0\n",
    "for i in range(n_rxn):\n",
    "    loss += cp.norm2(cp.pos(cp.log_sum_exp(LSE_expr[i])))\n",
    "loss += l * reg \n",
    "loss += e * reg2\n",
    "loss += f * reg3\n",
    "# "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 268,
   "id": "004cbea2-33e3-4128-bba3-2aece5cca605",
   "metadata": {},
   "outputs": [],
   "source": [
    "haldane = []\n",
    "fwd_flux = []\n",
    "\n",
    "for i, r in enumerate(S.T):\n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "    \n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "    \n",
    "    haldane.append(K_eq[i] == cfwd[i] - crev[i] + r[S_p_idx] @ Km_p[Km_p_idx] - (-r[S_s_idx]) @ Km_s[Km_s_idx])  # add minus since s matrix has minus\n",
    "    fwd_flux.append(cfwd[i] + (-r[S_s_idx]) @ y_s[Km_s_idx] - (crev[i] + r[S_p_idx] @ y_p[Km_p_idx])  >= 0)  # add minus since s matrix has minus"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 269,
   "id": "c2ec7761-6d1a-4e44-b798-bffab58cdc31",
   "metadata": {},
   "outputs": [],
   "source": [
    "constr = [cp.hstack([cfwd, crev, c, Km_s, Km_p]) >= -12,\n",
    "          cp.hstack([cfwd, crev, c, Km_s, Km_p]) <= 12, \n",
    "          ]\n",
    "\n",
    "if n_Km_i:\n",
    "    constr.extend([Km_i >= -12, Km_i <= 12])\n",
    "if n_Km_a:\n",
    "    constr.extend([Km_a >= -12, Km_a <= 12])\n",
    "\n",
    "constr.extend(haldane)\n",
    "constr.extend(fwd_flux)\n",
    "constr.extend([S.T @ c <= K_eq])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 270,
   "id": "1aacba37-98cb-40f8-9d5f-6f9a053acbbc",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "0.0003037242788229941"
     },
     "execution_count": 270,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "p = cp.Problem(cp.Minimize(loss), constr)\n",
    "p.solve(verbose=False, solver=cp.ECOS)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 270,
   "id": "b3ae86a8-96d3-4c20-902b-133cc9ae4b6d",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 271,
   "id": "6d9cb71d-17e6-40bf-b57a-f6f1201418bb",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Substrate Km: ['1.000', '1.000', '1.000', '1.000', '1.000', '1.000', '1.000']\n",
      "Product Km: ['1.000', '1.254', '1.254', '1.254', '1.301', '1.000', '1.000']\n",
      "Fwd kcat: ['2335.276', '84.350', '86.378', '28.344']\n",
      "Rev kcat: ['0.946', '0.015', '7.846', '2.939']\n",
      "Concentrations: ['1.000', '1.000', '1.000', '1.000', '1.000', '1.000', '1.251', '2.221', '2.221']\n",
      "Activation Km: ['0.562', '0.583']\n"
     ]
    }
   ],
   "source": [
    "print('Substrate Km:', [f'{val:.3f}' for val in np.exp(Km_s.value)])\n",
    "print('Product Km:', [f'{val:.3f}' for val in np.exp(Km_p.value)])\n",
    "print('Fwd kcat:', [f'{val:.3f}' for val in np.exp(cfwd.value)])\n",
    "print('Rev kcat:', [f'{val:.3f}' for val in np.exp(crev.value)])\n",
    "print('Concentrations:', [f'{val:.3f}' for val in np.exp(c.value)])\n",
    "\n",
    "if n_Km_i:\n",
    "    print('Inhibition Km:', [f'{val:.3f}' for val in np.exp(Km_i.value)])\n",
    "if n_Km_a:\n",
    "    print('Activation Km:', [f'{val:.3f}' for val in np.exp(Km_a.value)])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fca387c4-48f6-4284-bd4c-58dd5a9df98f",
   "metadata": {},
   "source": [
    "## Check equilibrium"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 272,
   "id": "85dc0a11-f3da-4a5d-9fc8-bb8dbf1b27ca",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([ True,  True,  True,  True])"
     },
     "execution_count": 272,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "S.T @ c.value <= K_eq"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 273,
   "id": "71ee10ab-ffe5-4b4b-b49c-369f66046a91",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([ 8.88268506e-07, -2.23548501e-01, -1.37238173e+00, -2.23559093e-01])"
     },
     "execution_count": 273,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "S.T @ c.value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 274,
   "id": "f64070ee-086b-449c-906a-2709e8aa0e23",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([8.49199084, 8.89452745, 2.39876944, 2.26629785])"
     },
     "execution_count": 274,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "K_eq"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dec12056-d8b5-41ca-baa7-422b6f0fac38",
   "metadata": {},
   "source": [
    "## Check flux reconstruction with inhibition/activation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 275,
   "id": "7d487012-6835-43b4-b1b3-9510c066b502",
   "metadata": {},
   "outputs": [],
   "source": [
    "sat_expr = []\n",
    "fwd_sat = np.zeros(n_rxn)\n",
    "back_sat = np.zeros(n_rxn)\n",
    "sat = np.zeros(n_rxn)\n",
    "\n",
    "for i in range(n_rxn):\n",
    "    # sum terms are separate in logsumexp. one per saturation term (row in C_alpha, C_beta)\n",
    "    n_term_s = np.sum(d_alpha == i) \n",
    "    n_term_p = np.sum(d_beta == i)\n",
    "    n_term = n_term_s + n_term_p\n",
    "    \n",
    "    \n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "    \n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "    \n",
    "    #S_s_idx = S_s_nz[0, S_s_nz[1, :] == i]\n",
    "    \n",
    "    sat_expr.append(           [ (C_alpha @ y_f.value)[d_alpha == i] ,  \n",
    "                                 (C_beta @ y_r.value)[d_beta == i],\n",
    "                                 0,\n",
    "                                 #-1*np.ones(n_lse_terms - n_term + 1) \n",
    "                               ]\n",
    "                   )\n",
    "    fwd_sat[i] = (np.exp(-S.T[i, S_s_idx] @ y_s.value[Km_s_idx])) # + cfwd.value[i]\n",
    "    back_sat[i] = (np.exp(S.T[i, S_p_idx] @ y_p.value[Km_p_idx])) # + cfwd.value[i]\n",
    "    \n",
    "    \n",
    "\n",
    "for i, rxn in enumerate(sat_expr):\n",
    "    s = 0\n",
    "    \n",
    "    for term in rxn:\n",
    "        s += np.sum(np.exp(term))\n",
    "        \n",
    "    sat[i] = (s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 276,
   "id": "137a8d97-36b6-47d6-89d8-5cc67da64f6f",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([100.48120083,  20.01743462,  30.00031371,  10.00005803])"
     },
     "execution_count": 276,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.exp(cfwd.value) * fwd_sat/sat - np.exp(crev.value) * back_sat/sat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 277,
   "id": "876a78e3-8871-4951-a94f-176508dec699",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([-0.57594296, -0.53950781])"
     },
     "execution_count": 277,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Km_a.value"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b5972830-a1cf-4623-8e47-89ecea910982",
   "metadata": {},
   "source": [
    "Both enzymes have a much higher concentration than K_a, e.g. both are activated."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 278,
   "id": "0f94615b-1962-4fb2-92c9-53f159fc4f22",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([1.77880537, 1.71516246])"
     },
     "execution_count": 278,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.exp(-y_a.value)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6269f04e-fb7e-459b-b2fd-091c89a20936",
   "metadata": {},
   "source": [
    "About 99%."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "44701e69-9a4b-4681-82e2-250c1804ba5c",
   "metadata": {
    "jp-MarkdownHeadingCollapsed": true,
    "tags": []
   },
   "source": [
    "# Reworking directionality to just rearrange terms, so we can add multiple substrate sets. One flux set to compare to previous"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 279,
   "id": "78ba688c-c5cd-4c30-89c5-85c57321b036",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "          6PFRUCTPHOS-RXN  F16ALDOLASE-RXN  2TRANSKETO-RXN  \\\n$K_{eq}$         8.491991        -8.894527        2.398769   \n$v$            100.000000       -20.000000       30.000000   \nsign             1.000000        -1.000000        1.000000   \n\n          TRIOSEPISOMERIZATION-RXN  \n$K_{eq}$                  2.266298  \n$v$                      10.000000  \nsign                      1.000000  ",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>6PFRUCTPHOS-RXN</th>\n      <th>F16ALDOLASE-RXN</th>\n      <th>2TRANSKETO-RXN</th>\n      <th>TRIOSEPISOMERIZATION-RXN</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>$K_{eq}$</th>\n      <td>8.491991</td>\n      <td>-8.894527</td>\n      <td>2.398769</td>\n      <td>2.266298</td>\n    </tr>\n    <tr>\n      <th>$v$</th>\n      <td>100.000000</td>\n      <td>-20.000000</td>\n      <td>30.000000</td>\n      <td>10.000000</td>\n    </tr>\n    <tr>\n      <th>sign</th>\n      <td>1.000000</td>\n      <td>-1.000000</td>\n      <td>1.000000</td>\n      <td>1.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 279,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "K_eq = np.log(keq)\n",
    "#vE = np.array([100, 20, -30, -10])\n",
    "\n",
    "# K_eq[vE < 0] = 1/K_eq[vE < 0] \n",
    "\n",
    "lvE = np.log(np.abs(vE))\n",
    "pd.DataFrame(np.array([K_eq, vE, np.sign(vE, dtype=np.int8)]), columns=Sd.columns, index=[\"$K_{eq}$\", \"$v$\", \"sign\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 280,
   "id": "0fa1b725-8024-4208-a4ba-c10ec77f809c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# set up variables\n",
    "\n",
    "S = np.array(Sd)\n",
    "# S = np.multiply(S, vE/np.abs(vE)).astype(np.int8) # flips signs on reverse reactions, not needed\n",
    "# S[S == -0] = 0\n",
    "S_s = -np.copy(S) # reverse neg sign\n",
    "S_p = np.copy(S) \n",
    "S_s[S > 0] = 0 # zeros products\n",
    "S_p[S < 0] = 0 # zeros substrates\n",
    "S_i = np.copy(np.array(Sr) == -1) # reaction direction does not matter\n",
    "S_a = np.copy(np.array(Sr) == 1)\n",
    "\n",
    "\n",
    "S_s_nz = np.array(S_s.nonzero())\n",
    "S_p_nz = np.array(S_p.nonzero())\n",
    "S_i_nz = np.array(S_i.nonzero())\n",
    "S_a_nz = np.array(S_a.nonzero())\n",
    "\n",
    "# TODO Refactor all the below lines as one liners \n",
    "# first coordinate, e.g. metabolites w nonzero substrate/product coeff across all reactions. also works as substrate indices. \n",
    "met_s_nz = S_s_nz[0, :]\n",
    "met_p_nz = S_p_nz[0, :]\n",
    "met_i_nz = S_i_nz[0, :]\n",
    "met_a_nz = S_a_nz[0, :]\n",
    "\n",
    "# second coordinate, e.g. reactions indices for those concentrations. works to index substrates as well. \n",
    "rxn_s_nz = S_s_nz[1, :]   \n",
    "rxn_p_nz = S_p_nz[1, :]\n",
    "rxn_i_nz = S_i_nz[1, :]\n",
    "rxn_a_nz = S_a_nz[1, :]\n",
    "\n",
    "# one dim is always 2\n",
    "n_Km_s = np.max(met_s_nz.shape) \n",
    "n_Km_p = np.max(met_p_nz.shape)\n",
    "n_Km_i = np.max(met_i_nz.shape) \n",
    "n_Km_a = np.max(met_a_nz.shape)\n",
    "\n",
    "c = cp.Variable(n_met)\n",
    "Km_s = cp.Variable(n_Km_s)\n",
    "Km_p = cp.Variable(n_Km_p)\n",
    "Km_i = cp.Variable(n_Km_i) if n_Km_i else None\n",
    "Km_a = cp.Variable(n_Km_a) if n_Km_a else None\n",
    "\n",
    "cfwd = cp.Variable(n_rxn)\n",
    "crev = cp.Variable(n_rxn)\n",
    "\n",
    "# define Km positions by nonzero S matrix concentrations. Activation is reverse val of inhibition. \n",
    "y_s = c[met_s_nz] - Km_s\n",
    "y_p = c[met_p_nz] - Km_p\n",
    "y_i = c[met_i_nz] - Km_i if n_Km_i else None\n",
    "y_a = -(c[met_a_nz] - Km_a) if n_Km_a else None\n",
    "\n",
    "# saturation stacks\n",
    "if n_Km_i and n_Km_a:\n",
    "    y_f = cp.hstack((y_s, y_i, y_a))\n",
    "    y_r = cp.hstack((y_p, y_i, y_a))\n",
    "elif n_Km_i:\n",
    "    y_f = cp.hstack((y_s, y_i))\n",
    "    y_r = cp.hstack((y_p, y_i))\n",
    "elif n_Km_a:\n",
    "    y_f = cp.hstack((y_s, y_a))\n",
    "    y_r = cp.hstack((y_p, y_a))\n",
    "else:\n",
    "    y_f = y_s\n",
    "    y_r = y_p"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 281,
   "id": "84de423e-67c2-402c-b7b4-3c7007e205cf",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([[-1,  0,  1,  0],\n       [-1,  0,  0,  0],\n       [ 1,  0,  0,  0],\n       [ 1,  0,  0,  0],\n       [ 1, -1,  0,  0],\n       [ 0,  1,  0,  1],\n       [ 0,  1,  1, -1],\n       [ 0,  0, -1,  0],\n       [ 0,  0, -1,  0]], dtype=int8)"
     },
     "execution_count": 281,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "S"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 282,
   "id": "f2c7b291-51aa-44db-bb1a-d9cdb22d2090",
   "metadata": {},
   "outputs": [],
   "source": [
    "# number of saturation terms for sub, prod\n",
    "S_s_comb = np.concatenate((S_s, S_i, S_a), axis=0)\n",
    "S_p_comb = np.concatenate((S_p, S_i, S_a), axis=0)\n",
    "n_alpha = np.sum(np.power(2, S_s_comb.sum(axis=0)) - 1)\n",
    "n_beta = np.sum(np.power(2, S_p_comb.sum(axis=0)) - 1)\n",
    "\n",
    "# saturation matrix setup, first sub, then inhib, then act. \n",
    "C_alpha = np.zeros([n_alpha, len(met_s_nz) + len(met_i_nz) + len(met_a_nz)])\n",
    "C_beta = np.zeros([n_beta, len(met_p_nz) + len(met_i_nz) + len(met_a_nz)])\n",
    "\n",
    "# to separate different reactions saturation terms to their individual reaction equations. \n",
    "d_alpha = np.zeros(n_alpha, dtype=np.int8)\n",
    "d_beta = np.zeros(n_beta, dtype=np.int8)\n",
    "\n",
    "\n",
    "idx = 0\n",
    "\n",
    "for i in range(n_rxn):\n",
    "    \n",
    "    # pick one reaction at a time (get substrate indicies)\n",
    "    #idx_cur_rxn = rxn_s_nz == i\n",
    "    idx_cur_rxn = np.concatenate((rxn_s_nz == i, rxn_i_nz == i, rxn_a_nz == i))\n",
    "    \n",
    "    # generates all binary permutations minus the first one since that would result in -1\n",
    "    sat_perm = np.array(list(itertools.product([0, 1], repeat=sum(idx_cur_rxn))))\n",
    "    sat_perm = sat_perm[1:, :]\n",
    "    \n",
    "    r, _ = sat_perm.shape\n",
    "    \n",
    "    # replace zeros with saturation matrix\n",
    "    C_alpha[idx:(idx+r), idx_cur_rxn] = sat_perm\n",
    "    d_alpha[idx:(idx+r)] = i\n",
    "        \n",
    "    idx += r # add row # \n",
    "\n",
    "idx = 0\n",
    "    \n",
    "for i in range(n_rxn):\n",
    "    idx_cur_rxn = np.concatenate((rxn_p_nz == i, rxn_i_nz == i, rxn_a_nz == i))\n",
    "    \n",
    "    sat_perm = np.array(list(itertools.product([0, 1], repeat=sum(idx_cur_rxn))))\n",
    "    sat_perm = sat_perm[1:, :]\n",
    "    \n",
    "    r, _ = sat_perm.shape\n",
    "    \n",
    "    C_beta[idx:(idx+r), idx_cur_rxn] = sat_perm\n",
    "    d_beta[idx:(idx+r)] = i\n",
    "        \n",
    "    idx += r # add row # "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 283,
   "id": "8f9bc9b7-de93-4c01-8ff5-89199d4dfd8a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "[Expression(AFFINE, UNKNOWN, (48,)),\n Expression(AFFINE, UNKNOWN, (6,)),\n Expression(AFFINE, UNKNOWN, (8,)),\n Expression(AFFINE, UNKNOWN, (4,))]"
     },
     "execution_count": 283,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "n_lse_terms = np.max(np.power(2, S_s.sum(axis=0)) +  np.power(2, S_p.sum(axis=0)) - 2)\n",
    "LSE_expr = []\n",
    "\n",
    "sign = np.sign(vE)\n",
    "lvE = np.log(sign * vE)\n",
    "\n",
    "for i in range(n_rxn):\n",
    "    # sum terms are separate in logsumexp. one per saturation term (row in C_alpha, C_beta)\n",
    "    \n",
    "    n_term_s = np.sum(d_alpha == i) \n",
    "    n_term_p = np.sum(d_beta == i)\n",
    "    n_term = n_term_s + n_term_p\n",
    "    \n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "    \n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "    \n",
    "    if sign[i] == 1:\n",
    "        LSE_expr.append(cp.hstack( [ lvE[i] + (C_alpha @ y_f)[d_alpha == i] - cp.multiply(np.ones(n_term_s), - S.T[i, S_s_idx] @ y_s[Km_s_idx]) - cfwd[i],  \n",
    "                                     lvE[i] + (C_beta @ y_r)[d_beta == i] - cp.multiply(np.ones(n_term_p), - S.T[i, S_s_idx] @ y_s[Km_s_idx]) - cfwd[i],\n",
    "                                     lvE[i] + 0 - cp.multiply(np.ones(1), -S.T[i, S_s_idx] @ y_s[Km_s_idx])  - cfwd[i],\n",
    "                                     cp.multiply(np.ones(1), S.T[i, S_p_idx] @ y_p[Km_p_idx])  + crev[i]\n",
    "                                     - cp.multiply(np.ones(1), -S.T[i, S_s_idx] @ y_s[Km_s_idx])  - cfwd[i]\n",
    "                                     #-1*np.ones(n_lse_terms - n_term + 1) \n",
    "                                   ]\n",
    "                                 )\n",
    "                       )  # remove +1 here, could also have cfwd outside objec. \n",
    "        \n",
    "    # keep saturation term the same, switch around fwd and rev terms. flip all signs with S matrix since it's signed. \n",
    "    if sign[i] == -1:\n",
    "        LSE_expr.append(cp.hstack( [ lvE[i] + (C_alpha @ y_f)[d_alpha == i] - cp.multiply(np.ones(n_term_s), S.T[i, S_p_idx] @ y_p[Km_p_idx]) - crev[i],  \n",
    "                                     lvE[i] + (C_beta @ y_r)[d_beta == i] - cp.multiply(np.ones(n_term_p), S.T[i, S_p_idx] @ y_p[Km_p_idx]) - crev[i],\n",
    "                                     lvE[i] + 0 - cp.multiply(np.ones(1), S.T[i, S_p_idx] @ y_p[Km_p_idx]) - crev[i],\n",
    "                                     cp.multiply(np.ones(1), - S.T[i, S_s_idx] @ y_s[Km_s_idx])  + cfwd[i]\n",
    "                                     - cp.multiply(np.ones(1), S.T[i, S_p_idx] @ y_p[Km_p_idx]) - crev[i],\n",
    "                                     #-1*np.ones(n_lse_terms - n_term + 1) \n",
    "                                   ]\n",
    "                                 )\n",
    "                       )\n",
    "    \n",
    "#LSE_expr = cp.vstack(LSE_expr)\n",
    "LSE_expr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 284,
   "id": "46556e00-d226-4552-bdf2-036d770cd0e0",
   "metadata": {},
   "outputs": [],
   "source": [
    "l = 0.0000001\n",
    "e = 0.00001\n",
    "f = 0.0000001\n",
    "reg =  cp.sum(cp.hstack([cfwd, crev, c])) + cp.sum(cp.hstack([-Km_s, -Km_p]))# regularization\n",
    "reg2 = cp.norm1(cp.hstack([cfwd, crev, c])) + cp.norm1(cp.hstack([-Km_s, -Km_p]))# regularization\n",
    "reg3 = cp.sum(cp.huber(cp.hstack([y_s, y_p]), 1))\n",
    "\n",
    "if n_Km_i:\n",
    "    reg += cp.sum(cp.hstack([-Km_i]))\n",
    "if n_Km_a:\n",
    "    reg += cp.sum(cp.hstack([-Km_a]))\n",
    "#reg3 = cp.norm1(cp.hstack([y_s, y_p])) # take a look at this\n",
    "\n",
    "loss = 0\n",
    "for i in range(n_rxn):\n",
    "    loss += cp.norm2(cp.pos(cp.log_sum_exp(LSE_expr[i])))\n",
    "loss += l * reg \n",
    "loss += e * reg2\n",
    "loss += f * reg3\n",
    "# "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 285,
   "id": "683d5edf-a9df-49d9-a455-f44f87c87fdc",
   "metadata": {},
   "outputs": [],
   "source": [
    "constr = [cp.hstack([cfwd, crev, c, Km_s, Km_p]) >= -12,\n",
    "          cp.hstack([cfwd, crev, c, Km_s, Km_p]) <= 12,\n",
    "          ]\n",
    "\n",
    "if n_Km_i:\n",
    "    constr.extend([Km_i >= -12, Km_i <= 12])\n",
    "if n_Km_a:\n",
    "    constr.extend([Km_a >= -12, Km_a <= 12])\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 286,
   "id": "1ce681a9-0abc-41c2-a6a1-c1abae1c1a2b",
   "metadata": {},
   "outputs": [],
   "source": [
    "haldane = []\n",
    "fwd_flux = []\n",
    "equilibrium = []\n",
    "\n",
    "for i, r in enumerate(S.T):\n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "    \n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "    \n",
    "    haldane.append(K_eq[i] == cfwd[i] - crev[i] + r[S_p_idx] @ Km_p[Km_p_idx] - (-r[S_s_idx]) @ Km_s[Km_s_idx])  # add minus since s matrix has minus\n",
    "    \n",
    "    if sign[i] == 1:\n",
    "        fwd_flux.append(cfwd[i] + (-r[S_s_idx]) @ y_s[Km_s_idx] - (crev[i] + r[S_p_idx] @ y_p[Km_p_idx])  >= 0)  # add minus since s matrix has minus\n",
    "        # equilibrium.append(r @ c <= K_eq[i])\n",
    "        \n",
    "    if sign[i] == -1:\n",
    "        fwd_flux.append(cfwd[i] + (-r[S_s_idx]) @ y_s[Km_s_idx] - (crev[i] + r[S_p_idx] @ y_p[Km_p_idx])  <= 0)  # add minus since s matrix has minus\n",
    "        # equilibrium.append(r @ c >= K_eq[i])\n",
    "        \n",
    "        \n",
    "constr.extend(haldane)\n",
    "constr.extend(fwd_flux)\n",
    "# constr.extend(equilibrium)\n",
    "constr.extend([cp.multiply(S.T @ c, sign)  <= cp.multiply(K_eq, sign)])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 287,
   "id": "7165f3bc-4f92-4ecd-9fa5-72df801f2cfb",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "0.0003037242788229874"
     },
     "execution_count": 287,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "p = cp.Problem(cp.Minimize(loss), constr)\n",
    "p.solve(verbose=False, solver=cp.ECOS)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 288,
   "id": "a23ff96b-063d-4f2d-8704-824aa46b6947",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Substrate Km: ['1.000', '1.000', '1.301', '1.000', '1.000', '1.000']\n",
      "Product Km: ['1.000', '1.254', '1.254', '1.254', '1.000', '1.000', '1.000', '1.000']\n",
      "Fwd kcat: ['2335.276', '0.015', '86.378', '28.344']\n",
      "Rev kcat: ['0.946', '84.350', '7.846', '2.939']\n",
      "Concentrations: ['1.000', '1.000', '1.000', '1.000', '1.000', '1.000', '1.251', '2.221', '2.221']\n",
      "Activation Km: ['0.562', '0.583']\n"
     ]
    }
   ],
   "source": [
    "print('Substrate Km:', [f'{val:.3f}' for val in np.exp(Km_s.value)])\n",
    "print('Product Km:', [f'{val:.3f}' for val in np.exp(Km_p.value)])\n",
    "print('Fwd kcat:', [f'{val:.3f}' for val in np.exp(cfwd.value)])\n",
    "print('Rev kcat:', [f'{val:.3f}' for val in np.exp(crev.value)])\n",
    "print('Concentrations:', [f'{val:.3f}' for val in np.exp(c.value)])\n",
    "\n",
    "if n_Km_i:\n",
    "    print('Inhibition Km:', [f'{val:.3f}' for val in np.exp(Km_i.value)])\n",
    "if n_Km_a:\n",
    "    print('Activation Km:', [f'{val:.3f}' for val in np.exp(Km_a.value)])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 289,
   "id": "6b2045c6-2811-44a6-866d-1669a8cbe536",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Substrate Km: ['1.000', '1.000', '1.000', '1.000', '1.000', '1.000', '1.000']\n",
    "# Product Km: ['1.000', '1.254', '1.254', '1.254', '1.301', '1.000', '1.000']\n",
    "# Fwd kcat: ['2335.276', '84.350', '86.378', '28.344']\n",
    "# Rev kcat: ['0.946', '0.015', '7.846', '2.939']\n",
    "# Concentrations: ['1.000', '1.000', '1.000', '1.000', '1.000', '1.000', '1.251', '2.221', '2.221']\n",
    "# Activation Km: ['0.562', '0.583']\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d22a7c8e-d9de-4a4b-91ff-878b49c487ee",
   "metadata": {},
   "source": [
    "## Check equilibrium"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "id": "4f70bd67-fc44-4a91-8610-394365c463a9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([ 8.88268506e-07, -2.23548501e-01, -1.37238173e+00, -2.23559093e-01])"
     },
     "execution_count": 75,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.multiply(S.T @ c.value, sign)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "id": "1e450d61-0061-4ce9-ac57-799a7f0b7db0",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([8.49199084, 8.89452745, 2.39876944, 2.26629785])"
     },
     "execution_count": 76,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.multiply(K_eq, sign)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cb9f9c30-3c2c-402a-a0bc-c77ba84b4d61",
   "metadata": {},
   "source": [
    "## Check flux reconstruction with inhibition/activation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "id": "5e054d57-710b-4cf5-b54d-4a74deadbcea",
   "metadata": {},
   "outputs": [],
   "source": [
    "sat_expr = []\n",
    "fwd_sat = np.zeros(n_rxn)\n",
    "back_sat = np.zeros(n_rxn)\n",
    "sat = np.zeros(n_rxn)\n",
    "\n",
    "for i in range(n_rxn):\n",
    "    # sum terms are separate in logsumexp. one per saturation term (row in C_alpha, C_beta)\n",
    "    n_term_s = np.sum(d_alpha == i) \n",
    "    n_term_p = np.sum(d_beta == i)\n",
    "    n_term = n_term_s + n_term_p\n",
    "    \n",
    "    \n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "    \n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "    \n",
    "    #S_s_idx = S_s_nz[0, S_s_nz[1, :] == i]\n",
    "    \n",
    "    sat_expr.append(           [ (C_alpha @ y_f.value)[d_alpha == i] ,  \n",
    "                                 (C_beta @ y_r.value)[d_beta == i],\n",
    "                                 0,\n",
    "                                 #-1*np.ones(n_lse_terms - n_term + 1) \n",
    "                               ]\n",
    "                   )\n",
    "    fwd_sat[i] = (np.exp(-S.T[i, S_s_idx] @ y_s.value[Km_s_idx])) # + cfwd.value[i]\n",
    "    back_sat[i] = (np.exp(S.T[i, S_p_idx] @ y_p.value[Km_p_idx])) # + cfwd.value[i]\n",
    "    \n",
    "    \n",
    "\n",
    "for i, rxn in enumerate(sat_expr):\n",
    "    s = 0\n",
    "    \n",
    "    for term in rxn:\n",
    "        s += np.sum(np.exp(term))\n",
    "        \n",
    "    sat[i] = (s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "id": "209b4849-e84e-4d01-b174-6524e485609c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([1.00501814e+02, 2.19546227e-03, 3.07073675e+01, 1.09042591e+01])"
     },
     "execution_count": 78,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.exp(cfwd.value) * fwd_sat/sat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "id": "44cdde16-9cf3-4774-8eea-616bf5f9a367",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([ -0.0206134 , -20.01963009,  -0.70705377,  -0.90420111])"
     },
     "execution_count": 79,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "- np.exp(crev.value) * back_sat/sat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "id": "a5219ac6-8feb-46c9-add8-215a0e6dec4f",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([100.48120083, -20.01743462,  30.00031371,  10.00005803])"
     },
     "execution_count": 80,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.exp(cfwd.value) * fwd_sat/sat - np.exp(crev.value) * back_sat/sat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "id": "971b3404-a8d4-4beb-9912-641efbac7e5b",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([-0.57594296, -0.53950781])"
     },
     "execution_count": 81,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Km_a.value"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "696c8e18-e95c-4e4c-bb22-d5594e619c4a",
   "metadata": {},
   "source": [
    "Both enzymes have a much higher concentration than K_a, e.g. both are activated."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "id": "150ff29f-9c11-4a20-a2e1-c27f18ccbd31",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "array([1.77880537, 1.71516246])"
     },
     "execution_count": 82,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.exp(-y_a.value)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "id": "11b80a4d-f366-437d-9a36-4a82ac4f3936",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "c87faa95-2adf-4141-801c-8296d5cf3783",
   "metadata": {},
   "source": [
    "# Adding flux set"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "id": "c40d66ec-d3ac-4858-bef4-fbd8e5c85451",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "                             6PFRUCTPHOS-RXN  F16ALDOLASE-RXN  2TRANSKETO-RXN  \\\nFRUCTOSE-6P                               -1                0               1   \nATP                                       -1                0               0   \nPROTON                                     1                0               0   \nADP                                        1                0               0   \nFRUCTOSE-16-DIPHOSPHATE                    1               -1               0   \nDIHYDROXY-ACETONE-PHOSPHATE                0                1               0   \nGAP                                        0                1               1   \nERYTHROSE-4P                               0                0              -1   \nXYLULOSE-5-PHOSPHATE                       0                0              -1   \n\n                             TRIOSEPISOMERIZATION-RXN  \nFRUCTOSE-6P                                         0  \nATP                                                 0  \nPROTON                                              0  \nADP                                                 0  \nFRUCTOSE-16-DIPHOSPHATE                             0  \nDIHYDROXY-ACETONE-PHOSPHATE                         1  \nGAP                                                -1  \nERYTHROSE-4P                                        0  \nXYLULOSE-5-PHOSPHATE                                0  ",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>6PFRUCTPHOS-RXN</th>\n      <th>F16ALDOLASE-RXN</th>\n      <th>2TRANSKETO-RXN</th>\n      <th>TRIOSEPISOMERIZATION-RXN</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>FRUCTOSE-6P</th>\n      <td>-1</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ATP</th>\n      <td>-1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>PROTON</th>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ADP</th>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>FRUCTOSE-16-DIPHOSPHATE</th>\n      <td>1</td>\n      <td>-1</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>DIHYDROXY-ACETONE-PHOSPHATE</th>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>GAP</th>\n      <td>0</td>\n      <td>1</td>\n      <td>1</td>\n      <td>-1</td>\n    </tr>\n    <tr>\n      <th>ERYTHROSE-4P</th>\n      <td>0</td>\n      <td>0</td>\n      <td>-1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>XYLULOSE-5-PHOSPHATE</th>\n      <td>0</td>\n      <td>0</td>\n      <td>-1</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 83,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Sd = pd.DataFrame(stoich_dict, dtype=np.int8).fillna(0).astype(np.int8)\n",
    "# Sd = Sd.iloc[0:7, 0:2]\n",
    "\n",
    "n_met = len(Sd.index)\n",
    "n_rxn = len(Sd.columns)\n",
    "\n",
    "Sd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "id": "40d1893b-dd37-4210-b055-68b9d1d2c737",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "          6PFRUCTPHOS-RXN  F16ALDOLASE-RXN  2TRANSKETO-RXN  \\\n$K_{eq}$         8.491991        -8.894527        2.398769   \n$v_1$           90.000000        70.000000      -30.000000   \n$v_2$          100.000000       100.000000       30.000000   \n$v_3$          110.000000        60.000000       75.000000   \nsign 1           1.000000         1.000000       -1.000000   \nsign 2           1.000000         1.000000        1.000000   \nsign 3           1.000000         1.000000        1.000000   \n\n          TRIOSEPISOMERIZATION-RXN  \n$K_{eq}$                  2.266298  \n$v_1$                    50.000000  \n$v_2$                    50.000000  \n$v_3$                    50.000000  \nsign 1                    1.000000  \nsign 2                    1.000000  \nsign 3                    1.000000  ",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>6PFRUCTPHOS-RXN</th>\n      <th>F16ALDOLASE-RXN</th>\n      <th>2TRANSKETO-RXN</th>\n      <th>TRIOSEPISOMERIZATION-RXN</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>$K_{eq}$</th>\n      <td>8.491991</td>\n      <td>-8.894527</td>\n      <td>2.398769</td>\n      <td>2.266298</td>\n    </tr>\n    <tr>\n      <th>$v_1$</th>\n      <td>90.000000</td>\n      <td>70.000000</td>\n      <td>-30.000000</td>\n      <td>50.000000</td>\n    </tr>\n    <tr>\n      <th>$v_2$</th>\n      <td>100.000000</td>\n      <td>100.000000</td>\n      <td>30.000000</td>\n      <td>50.000000</td>\n    </tr>\n    <tr>\n      <th>$v_3$</th>\n      <td>110.000000</td>\n      <td>60.000000</td>\n      <td>75.000000</td>\n      <td>50.000000</td>\n    </tr>\n    <tr>\n      <th>sign 1</th>\n      <td>1.000000</td>\n      <td>1.000000</td>\n      <td>-1.000000</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>sign 2</th>\n      <td>1.000000</td>\n      <td>1.000000</td>\n      <td>1.000000</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>sign 3</th>\n      <td>1.000000</td>\n      <td>1.000000</td>\n      <td>1.000000</td>\n      <td>1.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 84,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "K_eq = np.log(keq)\n",
    "K_eq_mod = K_eq[:, np.newaxis].T\n",
    "vE = np.array([[90, 70, -30, 50], [100, 100, 30, 50], [110, 60, 75, 50]])\n",
    "\n",
    "n_flux_set = vE.shape[0]\n",
    "\n",
    "# K_eq[vE < 0] = 1/K_eq[vE < 0] \n",
    "\n",
    "lvE = np.log(np.abs(vE))\n",
    "pd.DataFrame(np.concatenate([K_eq_mod, vE, np.sign(vE, dtype=np.int8)]), columns=Sd.columns, \n",
    "             index=[\"$K_{eq}$\", \"$v_1$\", \"$v_2$\", \"$v_3$\", \"sign 1\", \"sign 2\", \"sign 3\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "id": "24e1a2b1-932e-4de3-92eb-deafc727c1db",
   "metadata": {},
   "outputs": [],
   "source": [
    "# set up variables\n",
    "\n",
    "S = np.array(Sd)\n",
    "# S = np.multiply(S, vE/np.abs(vE)).astype(np.int8) # flips signs on reverse reactions, not needed\n",
    "# S[S == -0] = 0\n",
    "S_s = -np.copy(S) # reverse neg sign\n",
    "S_p = np.copy(S) \n",
    "S_s[S > 0] = 0 # zeros products\n",
    "S_p[S < 0] = 0 # zeros substrates\n",
    "S_i = np.copy(np.array(Sr) == -1) # reaction direction does not matter\n",
    "S_a = np.copy(np.array(Sr) == 1)\n",
    "\n",
    "\n",
    "S_s_nz = np.array(S_s.nonzero())\n",
    "S_p_nz = np.array(S_p.nonzero())\n",
    "S_i_nz = np.array(S_i.nonzero())\n",
    "S_a_nz = np.array(S_a.nonzero())\n",
    "\n",
    "# TODO Refactor all the below lines as one liners \n",
    "# first coordinate, e.g. metabolites w nonzero substrate/product coeff across all reactions. also works as substrate indices. \n",
    "met_s_nz = S_s_nz[0, :]\n",
    "met_p_nz = S_p_nz[0, :]\n",
    "met_i_nz = S_i_nz[0, :]\n",
    "met_a_nz = S_a_nz[0, :]\n",
    "\n",
    "# second coordinate, e.g. reactions indices for those concentrations. works to index substrates as well. \n",
    "rxn_s_nz = S_s_nz[1, :]   \n",
    "rxn_p_nz = S_p_nz[1, :]\n",
    "rxn_i_nz = S_i_nz[1, :]\n",
    "rxn_a_nz = S_a_nz[1, :]\n",
    "\n",
    "# one dim is always 2\n",
    "n_Km_s = np.max(met_s_nz.shape) \n",
    "n_Km_p = np.max(met_p_nz.shape)\n",
    "n_Km_i = np.max(met_i_nz.shape) \n",
    "n_Km_a = np.max(met_a_nz.shape)\n",
    "\n",
    "c = cp.Variable([n_met, n_flux_set])\n",
    "Km_s = cp.Variable(n_Km_s)\n",
    "Km_p = cp.Variable(n_Km_p)\n",
    "Km_i = cp.Variable(n_Km_i) if n_Km_i else None\n",
    "Km_a = cp.Variable(n_Km_a) if n_Km_a else None\n",
    "\n",
    "cfwd = cp.Variable(n_rxn)\n",
    "crev = cp.Variable(n_rxn)\n",
    "\n",
    "# define y vecs\n",
    "y_s_t = []\n",
    "y_p_t = []\n",
    "y_i_t = []\n",
    "y_a_t = []\n",
    "\n",
    "# define Km positions by nonzero S matrix concentrations. Activation is reverse val of inhibition.\n",
    "# TODO Add molecularity here.\n",
    "for i in range(n_flux_set):\n",
    "    y_s_t.append(c[met_s_nz, i] - Km_s)\n",
    "    y_p_t.append(c[met_p_nz, i] - Km_p)\n",
    "    y_i_t.append(c[met_i_nz, i] - Km_i if n_Km_i else None)\n",
    "    y_a_t.append(-(c[met_a_nz, i] - Km_a) if n_Km_a else None)\n",
    "\n",
    "y_s = cp.vstack(y_s_t)\n",
    "y_p = cp.vstack(y_p_t)\n",
    "y_i = cp.vstack(y_i_t)\n",
    "y_a = cp.vstack(y_a_t)\n",
    "    \n",
    "# saturation stacks\n",
    "y_f_vec = [y_s]\n",
    "y_r_vec = [y_p]\n",
    "if n_Km_i:\n",
    "    y_f_vec.append(y_i)\n",
    "    y_r_vec.append(y_i)\n",
    "if n_Km_a:\n",
    "    y_f_vec.append(y_a)\n",
    "    y_r_vec.append(y_a)    \n",
    "\n",
    "y_f = cp.hstack(y_f_vec)\n",
    "y_r = cp.hstack(y_r_vec)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "id": "b1b29b6a-4722-445c-adcf-0af90268d044",
   "metadata": {},
   "outputs": [],
   "source": [
    "# number of saturation terms for sub, prod\n",
    "S_s_comb = np.concatenate((S_s, S_i, S_a), axis=0)\n",
    "S_p_comb = np.concatenate((S_p, S_i, S_a), axis=0)\n",
    "n_alpha = np.sum(np.power(2, S_s_comb.sum(axis=0)) - 1)\n",
    "n_beta = np.sum(np.power(2, S_p_comb.sum(axis=0)) - 1)\n",
    "\n",
    "# saturation matrix setup, first sub, then inhib, then act. \n",
    "C_alpha = np.zeros([n_alpha, len(met_s_nz) + len(met_i_nz) + len(met_a_nz)])\n",
    "C_beta = np.zeros([n_beta, len(met_p_nz) + len(met_i_nz) + len(met_a_nz)])\n",
    "\n",
    "# to separate different reactions saturation terms to their individual reaction equations. \n",
    "d_alpha = np.zeros(n_alpha, dtype=np.int8)\n",
    "d_beta = np.zeros(n_beta, dtype=np.int8)\n",
    "\n",
    "\n",
    "idx = 0\n",
    "\n",
    "for i in range(n_rxn):\n",
    "    \n",
    "    # pick one reaction at a time (get substrate indicies)\n",
    "    #idx_cur_rxn = rxn_s_nz == i\n",
    "    # TODO This does not properly multiply by molecularity. Alternatively, generate C_alpha and\n",
    "    # TODO beta without molecularity (first ==1) and then multiply by molecularity in the end.\n",
    "    idx_cur_rxn = np.concatenate((rxn_s_nz == i, rxn_i_nz == i, rxn_a_nz == i))\n",
    "    \n",
    "    # generates all binary permutations minus the first one since that would result in -1\n",
    "    sat_perm = np.array(list(itertools.product([0, 1], repeat=sum(idx_cur_rxn))))\n",
    "    sat_perm = sat_perm[1:, :]\n",
    "    \n",
    "    r, _ = sat_perm.shape\n",
    "    \n",
    "    # replace zeros with saturation matrix\n",
    "    C_alpha[idx:(idx+r), idx_cur_rxn] = sat_perm\n",
    "    d_alpha[idx:(idx+r)] = i\n",
    "        \n",
    "    idx += r # add row # \n",
    "\n",
    "idx = 0\n",
    "    \n",
    "for i in range(n_rxn):\n",
    "    idx_cur_rxn = np.concatenate((rxn_p_nz == i, rxn_i_nz == i, rxn_a_nz == i))\n",
    "    \n",
    "    sat_perm = np.array(list(itertools.product([0, 1], repeat=sum(idx_cur_rxn))))\n",
    "    sat_perm = sat_perm[1:, :]\n",
    "    \n",
    "    r, _ = sat_perm.shape\n",
    "    \n",
    "    C_beta[idx:(idx+r), idx_cur_rxn] = sat_perm\n",
    "    d_beta[idx:(idx+r)] = i\n",
    "        \n",
    "    idx += r # add row # "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "id": "2d2ec614-798c-44c8-be85-413bf53d78bb",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "[Expression(AFFINE, UNKNOWN, (48,)),\n Expression(AFFINE, UNKNOWN, (6,)),\n Expression(AFFINE, UNKNOWN, (8,)),\n Expression(AFFINE, UNKNOWN, (4,)),\n Expression(AFFINE, UNKNOWN, (48,)),\n Expression(AFFINE, UNKNOWN, (6,)),\n Expression(AFFINE, UNKNOWN, (8,)),\n Expression(AFFINE, UNKNOWN, (4,)),\n Expression(AFFINE, UNKNOWN, (48,)),\n Expression(AFFINE, UNKNOWN, (6,)),\n Expression(AFFINE, UNKNOWN, (8,)),\n Expression(AFFINE, UNKNOWN, (4,))]"
     },
     "execution_count": 87,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "n_lse_terms = np.max(np.power(2, S_s.sum(axis=0)) +  np.power(2, S_p.sum(axis=0)) - 2)\n",
    "LSE_expr = []\n",
    "denom_expr = []\n",
    "\n",
    "sign = np.sign(vE)\n",
    "lvE = np.log(sign * vE)\n",
    "\n",
    "for j in range(n_flux_set):\n",
    "    for i in range(n_rxn):\n",
    "        # sum terms are separate in logsumexp. one per saturation term (row in C_alpha, C_beta)\n",
    "\n",
    "        n_term_s = np.sum(d_alpha == i) \n",
    "        n_term_p = np.sum(d_beta == i)\n",
    "        n_term = n_term_s + n_term_p\n",
    "\n",
    "        Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "        S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "\n",
    "        Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "        S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "        \n",
    "        if sign[j, i] == 1:\n",
    "            LSE_expr.append(cp.hstack( [ \n",
    "                                         lvE[j, i] + (C_alpha @ cp.vec(y_f[j, :]))[d_alpha == i] \n",
    "                                            - cp.multiply(np.ones(n_term_s), - S.T[i, S_s_idx] @ cp.vec(y_s[j, Km_s_idx])) - cfwd[i],  \n",
    "                                         lvE[j, i] + (C_beta @ cp.vec(y_r[j, :]))[d_beta == i] \n",
    "                                            - cp.multiply(np.ones(n_term_p), - S.T[i, S_s_idx] @ cp.vec(y_s[j, Km_s_idx])) - cfwd[i],\n",
    "                \n",
    "                                         lvE[j, i] + 0 - cp.multiply(np.ones(1), -S.T[i, S_s_idx] @ cp.vec(y_s[j, Km_s_idx]))  - cfwd[i],\n",
    "                \n",
    "                                         cp.multiply(np.ones(1), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx]))  + crev[i]\n",
    "                                            - cp.multiply(np.ones(1), -S.T[i, S_s_idx] @ cp.vec(y_s[j, Km_s_idx]))  - cfwd[i],\n",
    "                \n",
    "                                       ]\n",
    "                                     )\n",
    "                           )  # remove +1 here, could also have cfwd outside objec.\n",
    "            \n",
    "            denom_expr.append(cp.multiply(np.ones(1), -S.T[i, S_s_idx] @ cp.vec(y_s[j, Km_s_idx])) + cfwd[i],)\n",
    "            \n",
    "\n",
    "        # keep saturation term the same, switch around fwd and rev terms. flip all signs with S matrix since it's signed. \n",
    "        if sign[j, i] == -1:\n",
    "            LSE_expr.append(cp.hstack( [ lvE[j, i] + (C_alpha @ cp.vec(y_f[j, :]))[d_alpha == i] \n",
    "                                            - cp.multiply(np.ones(n_term_s), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx])) - crev[i],  \n",
    "                                        \n",
    "                                         lvE[j, i] + (C_beta @ cp.vec(y_r[j, :]))[d_beta == i] \n",
    "                                            - cp.multiply(np.ones(n_term_p), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx])) - crev[i],\n",
    "                                        \n",
    "                                         lvE[j, i] + 0 - cp.multiply(np.ones(1), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx])) - crev[i],\n",
    "                                        \n",
    "                                         cp.multiply(np.ones(1), - S.T[i, S_s_idx] @ cp.vec(y_s[j, Km_s_idx]))  + cfwd[i]\n",
    "                                            - cp.multiply(np.ones(1), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx])) - crev[i],\n",
    "                                        \n",
    "                                       ]\n",
    "                                     )\n",
    "                           )\n",
    "            \n",
    "            denom_expr.append(cp.multiply(np.ones(1), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx])) + crev[i])\n",
    "            \n",
    "\n",
    "#LSE_expr = cp.vstack(LSE_expr)\n",
    "LSE_expr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "id": "e7bc83ed-8678-4596-8fa8-d594e941f045",
   "metadata": {},
   "outputs": [],
   "source": [
    "l = 0.001\n",
    "e = 0.001\n",
    "f = 0.000001\n",
    "reg =  cp.sum(cp.hstack([cfwd, crev, cp.vec(c)])) + cp.sum(cp.hstack([-Km_s, -Km_p])) # regularization\n",
    "reg2 = cp.norm1(cp.hstack([cfwd, crev, cp.vec(c)])) + cp.norm1(cp.hstack([-Km_s, -Km_p])) # regularization\n",
    "reg3 = cp.sum(cp.huber(cp.hstack([y_s, y_p]), 1)) # issue with matrix\n",
    "\n",
    "if n_Km_i:\n",
    "    reg += cp.sum(cp.hstack([-Km_i]))\n",
    "if n_Km_a:\n",
    "    reg += cp.sum(cp.hstack([-Km_a]))\n",
    "#reg3 = cp.norm1(cp.hstack([y_s, y_p])) # take a look at this\n",
    "\n",
    "loss = 0\n",
    "for i in range(len(LSE_expr)):\n",
    "    loss += cp.norm1(cp.pos(cp.log_sum_exp(LSE_expr[i])))\n",
    "for i in range(len(denom_expr)):\n",
    "    loss += 0.01 * denom_expr[i]\n",
    "loss += l * reg \n",
    "loss += e * reg2\n",
    "loss += f * reg3\n",
    "# "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "id": "7772e167-8115-4513-94c7-dce58e9392bd",
   "metadata": {},
   "outputs": [],
   "source": [
    "constr = [cp.hstack([cfwd, crev, cp.vec(c), Km_s, Km_p]) >= -12,\n",
    "          cp.hstack([cfwd, crev, cp.vec(c), Km_s, Km_p]) <= 12,\n",
    "          ]\n",
    "\n",
    "if n_Km_i:\n",
    "    constr.extend([Km_i >= -12, Km_i <= 12])\n",
    "if n_Km_a:\n",
    "    constr.extend([Km_a >= -12, Km_a <= 12])\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 90,
   "id": "4f417489-a4e9-496f-8967-297b575685a8",
   "metadata": {},
   "outputs": [],
   "source": [
    "constr.extend([Km_a[0] == -1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 91,
   "id": "05a47e3f-3555-43ad-89e4-939b4b27b149",
   "metadata": {},
   "outputs": [],
   "source": [
    "haldane = []\n",
    "fwd_flux = []\n",
    "\n",
    "for i, r in enumerate(S.T):\n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "\n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "\n",
    "    haldane.append(K_eq[i] == cfwd[i] - crev[i] + r[S_p_idx] @ Km_p[Km_p_idx] - (-r[S_s_idx]) @ Km_s[Km_s_idx])\n",
    "\n",
    "for j in range(n_flux_set):\n",
    "    for i, r in enumerate(S.T):\n",
    "        Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "        S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "\n",
    "        Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "        S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "\n",
    "        if sign[j, i] == 1:\n",
    "            fwd_flux.append(cfwd[i] + (-r[S_s_idx]) @ cp.vec(y_s[j, Km_s_idx]) - (crev[i] + r[S_p_idx] @ cp.vec(y_p[j, Km_p_idx]))  >= 0)  # add minus since s matrix has minus\n",
    "            # equilibrium.append(r @ c <= K_eq[i])\n",
    "\n",
    "        if sign[j, i] == -1:\n",
    "            fwd_flux.append(cfwd[i] + (-r[S_s_idx]) @ cp.vec(y_s[j, Km_s_idx]) - (crev[i] + r[S_p_idx] @ cp.vec(y_p[j, Km_p_idx]))  <= 0)  # add minus since s matrix has minus\n",
    "            # equilibrium.append(r @ c >= K_eq[i])\n",
    "        \n",
    "        \n",
    "    constr.extend([cp.multiply(S.T @ cp.vec(c[:, j]), sign[j, :])  <= cp.multiply(K_eq, sign[j, :])])\n",
    "        \n",
    "constr.extend(haldane)\n",
    "constr.extend(fwd_flux)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "id": "ce648a93-611d-4de9-b9c2-e705248c2477",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": "0.6597879150163977"
     },
     "execution_count": 92,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "p = cp.Problem(cp.Minimize(loss), constr)\n",
    "p.solve(verbose=False, solver=cp.ECOS)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "id": "d868f215-1b91-47a9-aebc-de86d93a7b2b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Substrate Km: ['76.921', '9.298', '11.451', '1.059', '3.384', '3.384']\n",
      "Product Km: ['105.634', '1.000', '4.070', '19.201', '0.033', '0.033', '1.000', '1.000']\n",
      "Fwd kcat: ['44626.461', '1325.333', '5114.664', '847.467']\n",
      "Rev kcat: ['1.000', '27646.576', '4284.548', '2.719']\n",
      "Concentration: ['13.3903', '0.1482', '0.0002', '0.1624', '0.6842', '0.0000', '0.0664', '0.0006', '0.0006']\n",
      "Concentration: ['2.5741', '1.0000', '0.0002', '0.1599', '1.0000', '0.0000', '0.0664', '0.3197', '0.3197']\n",
      "Concentration: ['2.7533', '1.0000', '0.0002', '0.1609', '0.5823', '0.0000', '0.0664', '0.5041', '0.5041']\n",
      "Activation Km: ['0.368', '0.003']\n"
     ]
    }
   ],
   "source": [
    "print('Substrate Km:', [f'{val:.3f}' for val in np.exp(Km_s.value)])\n",
    "print('Product Km:', [f'{val:.3f}' for val in np.exp(Km_p.value)])\n",
    "print('Fwd kcat:', [f'{val:.3f}' for val in np.exp(cfwd.value)])\n",
    "print('Rev kcat:', [f'{val:.3f}' for val in np.exp(crev.value)])\n",
    "\n",
    "concs = np.exp(c.value).T\n",
    "for row in concs:\n",
    "    print('Concentration:', [f'{val:.4f}' for val in row])\n",
    "\n",
    "if n_Km_i:\n",
    "    print('Inhibition Km:', [f'{val:.3f}' for val in np.exp(Km_i.value)])\n",
    "if n_Km_a:\n",
    "    print('Activation Km:', [f'{val:.3f}' for val in np.exp(Km_a.value)])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 94,
   "id": "c2d37cd8-642c-4a89-9774-35dbc82fa1bd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "-1.030589966033446e-06\n",
      "-1.5818914703147335e-07\n",
      "-1.4069550624551397e-07\n",
      "-1.6061000444184126e-07\n",
      "-9.194091360464896e-07\n",
      "-1.3664577383498688e-07\n",
      "-2.0291436253483397e-07\n",
      "-8.977933091403045e-08\n",
      "-9.650457450383065e-07\n",
      "-1.5987101591175001e-07\n",
      "-1.9301848680486344e-07\n",
      "-9.689243894717148e-08\n"
     ]
    }
   ],
   "source": [
    "for v in LSE_expr:\n",
    "    #print(v.value)\n",
    "    print(logsumexp(v.value))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f71f2d28-e630-448a-91c1-abd47a28543e",
   "metadata": {},
   "source": [
    "Perfect? Wow."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5ba22b98-c325-4548-a2ff-5d62225ad78f",
   "metadata": {},
   "source": [
    "# Check flux reconstruction with inhibition/activation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 95,
   "id": "134d5038-95e8-4f0f-9b63-59c831cfe969",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 90.00009275  70.00001112 -30.00000422  50.00000803]\n",
      "[100.00009194 100.00001371  30.00000718  50.00000449]\n",
      "[110.00010616  60.00000964  75.00001549  50.00000484]\n"
     ]
    }
   ],
   "source": [
    "reconstructed_vE = np.zeros(vE.shape)\n",
    "\n",
    "for j in range(n_flux_set):\n",
    "    sat_expr = []\n",
    "    fwd_sat = np.zeros(n_rxn)\n",
    "    back_sat = np.zeros(n_rxn)\n",
    "    sat = np.zeros(n_rxn)\n",
    "\n",
    "    for i in range(n_rxn):\n",
    "        # sum terms are separate in logsumexp. one per saturation term (row in C_alpha, C_beta)\n",
    "        n_term_s = np.sum(d_alpha == i) \n",
    "        n_term_p = np.sum(d_beta == i)\n",
    "        n_term = n_term_s + n_term_p\n",
    "\n",
    "\n",
    "        Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "        S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "\n",
    "        Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "        S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "\n",
    "        #S_s_idx = S_s_nz[0, S_s_nz[1, :] == i]\n",
    "\n",
    "        sat_expr.append(           [ (C_alpha @ y_f.value[j, :].flatten())[d_alpha == i] ,  \n",
    "                                     (C_beta @ y_r.value[j, :].flatten())[d_beta == i],\n",
    "                                     0,\n",
    "                                     #-1*np.ones(n_lse_terms - n_term + 1) \n",
    "                                   ]\n",
    "                       )\n",
    "        fwd_sat[i] = (np.exp(-S.T[i, S_s_idx] @ y_s.value[j, Km_s_idx].flatten())) # + cfwd.value[i]\n",
    "        back_sat[i] = (np.exp(S.T[i, S_p_idx] @ y_p.value[j, Km_p_idx].flatten())) # + cfwd.value[i]\n",
    "\n",
    "\n",
    "\n",
    "    for i, rxn in enumerate(sat_expr):\n",
    "        s = 0\n",
    "\n",
    "        for term in rxn:\n",
    "            s += np.sum(np.exp(term))\n",
    "\n",
    "        sat[i] = (s)\n",
    "\n",
    "    reconstr = np.exp(cfwd.value) * fwd_sat/sat - np.exp(crev.value) * back_sat/sat\n",
    "    print(reconstr)\n",
    "    reconstructed_vE[j, :] = reconstr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "outputs": [
    {
     "data": {
      "text/plain": "         index                  variable       value                kind\n0   Flux set 1           6PFRUCTPHOS-RXN   90.000000         Actual flux\n1   Flux set 2           6PFRUCTPHOS-RXN  100.000000         Actual flux\n2   Flux set 3           6PFRUCTPHOS-RXN  110.000000         Actual flux\n3   Flux set 1           F16ALDOLASE-RXN   70.000000         Actual flux\n4   Flux set 2           F16ALDOLASE-RXN  100.000000         Actual flux\n5   Flux set 3           F16ALDOLASE-RXN   60.000000         Actual flux\n6   Flux set 1            2TRANSKETO-RXN  -30.000000         Actual flux\n7   Flux set 2            2TRANSKETO-RXN   30.000000         Actual flux\n8   Flux set 3            2TRANSKETO-RXN   75.000000         Actual flux\n9   Flux set 1  TRIOSEPISOMERIZATION-RXN   50.000000         Actual flux\n10  Flux set 2  TRIOSEPISOMERIZATION-RXN   50.000000         Actual flux\n11  Flux set 3  TRIOSEPISOMERIZATION-RXN   50.000000         Actual flux\n12  Flux set 1           6PFRUCTPHOS-RXN   90.000093  Reconstructed flux\n13  Flux set 2           6PFRUCTPHOS-RXN  100.000092  Reconstructed flux\n14  Flux set 3           6PFRUCTPHOS-RXN  110.000106  Reconstructed flux\n15  Flux set 1           F16ALDOLASE-RXN   70.000011  Reconstructed flux\n16  Flux set 2           F16ALDOLASE-RXN  100.000014  Reconstructed flux\n17  Flux set 3           F16ALDOLASE-RXN   60.000010  Reconstructed flux\n18  Flux set 1            2TRANSKETO-RXN  -30.000004  Reconstructed flux\n19  Flux set 2            2TRANSKETO-RXN   30.000007  Reconstructed flux\n20  Flux set 3            2TRANSKETO-RXN   75.000015  Reconstructed flux\n21  Flux set 1  TRIOSEPISOMERIZATION-RXN   50.000008  Reconstructed flux\n22  Flux set 2  TRIOSEPISOMERIZATION-RXN   50.000004  Reconstructed flux\n23  Flux set 3  TRIOSEPISOMERIZATION-RXN   50.000005  Reconstructed flux",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>index</th>\n      <th>variable</th>\n      <th>value</th>\n      <th>kind</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Flux set 1</td>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>90.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Flux set 2</td>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>100.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Flux set 3</td>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>110.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Flux set 1</td>\n      <td>F16ALDOLASE-RXN</td>\n      <td>70.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Flux set 2</td>\n      <td>F16ALDOLASE-RXN</td>\n      <td>100.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>Flux set 3</td>\n      <td>F16ALDOLASE-RXN</td>\n      <td>60.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>Flux set 1</td>\n      <td>2TRANSKETO-RXN</td>\n      <td>-30.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>Flux set 2</td>\n      <td>2TRANSKETO-RXN</td>\n      <td>30.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>Flux set 3</td>\n      <td>2TRANSKETO-RXN</td>\n      <td>75.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>Flux set 1</td>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>50.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>Flux set 2</td>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>50.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>Flux set 3</td>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>50.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>Flux set 1</td>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>90.000093</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>Flux set 2</td>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>100.000092</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>14</th>\n      <td>Flux set 3</td>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>110.000106</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>15</th>\n      <td>Flux set 1</td>\n      <td>F16ALDOLASE-RXN</td>\n      <td>70.000011</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>16</th>\n      <td>Flux set 2</td>\n      <td>F16ALDOLASE-RXN</td>\n      <td>100.000014</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>17</th>\n      <td>Flux set 3</td>\n      <td>F16ALDOLASE-RXN</td>\n      <td>60.000010</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>18</th>\n      <td>Flux set 1</td>\n      <td>2TRANSKETO-RXN</td>\n      <td>-30.000004</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>19</th>\n      <td>Flux set 2</td>\n      <td>2TRANSKETO-RXN</td>\n      <td>30.000007</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>20</th>\n      <td>Flux set 3</td>\n      <td>2TRANSKETO-RXN</td>\n      <td>75.000015</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>21</th>\n      <td>Flux set 1</td>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>50.000008</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>22</th>\n      <td>Flux set 2</td>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>50.000004</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>23</th>\n      <td>Flux set 3</td>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>50.000005</td>\n      <td>Reconstructed flux</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 96,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df_vE = pd.DataFrame(vE, columns=Sd.columns, index=[\"Flux set 1\", \"Flux set 2\", \"Flux set 3\"]).melt(ignore_index=False).reset_index(drop=False)\n",
    "df_vE[\"kind\"] = \"Actual flux\"\n",
    "df_recon = pd.DataFrame(reconstructed_vE, columns=Sd.columns, index=[\"Flux set 1\", \"Flux set 2\", \"Flux set 3\"]).melt(ignore_index=False).reset_index(drop=False)\n",
    "df_recon[\"kind\"] = \"Reconstructed flux\"\n",
    "\n",
    "df_reconstr_comp = pd.concat([df_vE, df_recon]).reset_index(drop=True)\n",
    "df_reconstr_comp"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 97,
   "outputs": [
    {
     "data": {
      "text/plain": "<Figure size 916.4x720 with 4 Axes>",
      "image/png": "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r66ujn79+mHVqlXYu3cvRo8eDSBjXG5wcLDcbVxdXSUJ3MePH6Ve76Crq4vKlStLJiz6fjywmJWVFfbv34+tW7fi6NGjCA0NhY6ODmrUqAEfHx907dpVbp2QkJCgMKZevXrh8OHDMDExybK768CBAxEWFoaQkBB07twZVatWRVhYGDZu3ChJIFNTU1GhQgUMGDAAo0ePhoGBgcx+vLy8FB4DyFsCB2R0v3R0dMT+/fuxfv16xMbG4unTp5gxYwZMTExk1re0tMTQoUMRGBiIFStWwM3NLcv916xZE0OGDEFgYGCe4iSi/CEScjvvLhEREREREf1QHANHRERERESkIpjAERERERERqQgmcERERERERCqCCRwREREREZGKYAJHRERERESkIvgaAQXS0wXExsYVdhhERACA0qVlpybPC9ZxRFSU5HcdR/QzYwscERERERGRimACR0REREREpCKYwBEREREREakIJnBEREREREQqggkcERERERGRimACR0REREREpCKYwBEREREREakIJnBEREREREQqggkcERERERGRimACR0REREREpCKYwBEREREREakIjcIOgIhUn56eNjQ0iubzIHX1jLjS0tILORLFUlPTER+fVNhhEBERkQpgAkdEeaahoYbkpBQ8fvCysEORYWFZDYlJKXjw7HVhhyJX9SrloKXJqpiIiIiUw7sGIsoXjx+8xOyJ6ws7DBk7IubjwfM3mOq1pbBDkWv5bGdYmFUq7DCIiIhIRRTNPk9EREREREQkgwkcERERERGRimACR0REREREpCKYwBEREREREakIJnBEREREREQqggkcERERERGRimACR0REREREpCKYwBEREREREakIJnBEREREREQqggkcERERERGRimACR0REREREpCKKVAJ39+5d1KlTB69fv5Yqj4yMRO/evWFlZQV7e3sEBgbKbHvz5k04OzvD2toaLVu2xPLly5GSkvKjQiciIiIiIipwRSaBe/jwIcaMGYPU1FSp8ujoaLi4uMDU1BR+fn5wdHSEt7c3AgICJOs8ffoUv/zyC7S1tbFy5UoMHz4cmzZtgpeX148+DSIiIiIiogKjUdgBpKamIjg4GMuWLYOmpqbMcl9fX1hYWMDHxwcAYGtri9TUVPj7+8PZ2RlaWlrYsGEDDAwMsHbtWmhpaaF169bQ0dHBokWLMGbMGJQtW/ZHnxYREREREVG+K/QWuCtXrmDp0qUYPnw4XF1dpZYlJSUhKioK7du3lyrv0KEDvnz5gujoaADA2bNnYWdnBy0tLck6HTt2RFpaGiIjIwv+JIiIiIiIiH6AQm+BMzMzw9GjR1GyZEmEhIRILYuJiUFKSgpMTEykyqtWrQoAePz4MaysrPDq1SuZdYyNjaGvr4/Hjx/nKi6RCDAy0s3VtvTjqKurQSQSFXYYColDE4TCjUMRQRCQlpae5/1oaKjnQzT/XRoa6j+8vmEdpxqKch1X1Os3IP/qOCKioqTQE7hSpUopXPb161cAgL6+vlS5np4eACAuLk7hOuL14uLi8itUKoJEIhES4r/h8YOXhR2KXBaW1ZCYlIIHz15nv/IPVr1KORTT1S7sMIgoC0W5jivK9RvAOo6Ifl6FnsBlRcjmsZ6amppS6+Tu2MDnz4m52pZ+HCMjXTx+8BKzJ64v7FDk2hExHw+ev8FUry2FHYqM5bOdYWFWKV9+z9mSkzepqWnZfg6lSxvk6zFZx6mGolzHFeX6DcjfOo4KXn7XcUQ/s0IfA5cVA4OML3N8fLxUubhVzcDAQNLylnkd8XrifRAREREREam6Ip3AValSBerq6nj27JlUufhnExMT6OnpoWzZsnj69KnUOrGxsYiPj5cZG0dERERERKSqinQCp62tDRsbGxw+fFiqq+ShQ4dgYGCAunXrAgBatGiBEydOIDk5WWoddXV1NG7c+IfHTUREREREVBCKdAIHAGPHjkV0dDSmTJmCU6dOYeXKlQgICMCYMWOgq5sx7mbkyJF49+4dRo8ejRMnTkhe4t2vXz9UqFChkM+AiIiIiIgofxT5BK5Zs2bw8/PDw4cPMX78eOzfvx8zZszAqFGjJOuYmZkhMDAQCQkJmDRpEjZt2oRhw4Zhzpw5hRg5ERERERFR/ipSs1D26tULvXr1kil3cHCAg4NDltva2Nhg586dBRUaERERERFRoSvyLXBERERERESUgQkcERERERGRimACR0REREREpCKYwBEREREREakIJnBEREREREQqggkcERERERGRimACR0REREREpCKYwBEREREREakIJnBEREREREQqggkcERERERGRitAo7ABUlZ6eNjQ0im7+q66eEVtaWnohRyJfamo64uOTCjsMIiIiIiKVwgQulzQ01JCclILHD14WdihyWVhWQ2JSCh48e13YocioXqUctDT5q0dERERElFO8i86Dxw9eYvbE9YUdhlw7IubjwfM3mOq1pbBDkbF8tjMszCoVdhhERERERCqn6PYBJCIiIiIiIilM4IiIiIiIiFQEEzgiIiIiIiIVwQSOiIiIiIhIRTCBIyIiIiIiUhFM4IiIiIiIiFQEEzgiIiIiIiIVwQSOiIiIiIhIRTCBIyIiIiIiUhFM4IiIiIiIiFQEEzgiIiIiIiIVoTIJ3Pbt29GpUyfUr18fjo6O2Ldvn9TyyMhI9O7dG1ZWVrC3t0dgYGAhRUpERERERFQwVCKBCw4OhoeHB9q0aYO1a9eiefPmmD59OiIiIgAA0dHRcHFxgampKfz8/ODo6Ahvb28EBAQUcuRERERERET5R6OwA1BGaGgomjRpgpkzZwIAmjdvjlu3buGvv/5Cp06d4OvrCwsLC/j4+AAAbG1tkZqaCn9/fzg7O0NLS6swwyciIiIiIsoXKtECl5SUBD09Pamy4sWL49OnT0hKSkJUVBTat28vtbxDhw748uULoqOjf2SoREREREREBUYlWuCGDBmC3377DREREWjVqhUiIyNx8uRJTJkyBTExMUhJSYGJiYnUNlWrVgUAPH78GE2bNs3xMUUiwMhIV+FyDQ31HO+T/qWhoZ7l9c3Jfij3+DkUDfn1OeREdnUcFQ38buVNYXy3iIgKmkokcF26dMGFCxfw66+/Ssp69uyJkSNH4urVqwAAfX19qW3ELXZxcXE/LE4iIiIiIqKCpBIJ3NixY3H16lXMnj0bFhYWuH79OtauXQt9fX107tw5y23V1HLXS1QQgM+fExUu5xO9vElNTcvy+iqLn0Pe8HMoGpT5HEqXNsjXY2ZXx1HRwO9W3uRXHUcFL7/rOKKfWZFP4KKjoxEZGQkvLy/06tULANC4cWMYGhpi7ty56NOnDwAgPj5eajtxy5uBASsEIiIiIiL6ORT5SUxevnwJAGjQoIFUuY2NDQDg7t27UFdXx7Nnz6SWi3/OPDaOiIiIiIhIVRX5BE6cgF25ckWq/Nq1awAAU1NT2NjY4PDhwxAEQbL80KFDMDAwQN26dX9YrERERERERAWpyHehrFOnDtq1awdPT098/foVtWvXxq1bt7BmzRrY2trCysoKY8eOxbBhwzBlyhT07NkTV69eRUBAAKZNmwZdXY4fICIiIiKin0ORT+AAYMWKFVi9ejX+/PNPxMbGomLFihg+fDhGjx4NAGjWrBn8/Pzg6+uL8ePHo2zZspgxYwaGDx9eyJETERERERHlH5VI4LS0tDB16lRMnTpV4ToODg5wcHD4gVERERERERH9WEV+DBwRERERERFlYAJHRERERESkIpjAERERERERqQgmcERERERERCqCCRwREREREZGKYAJHRERERESkIpjAERERERERqQgmcERERERERCqCCRwREREREZGKYAJHRERERESkIjQKOwAiIip69PS0oaFRNJ/xqatnxJWWll7IkSiWmpqO+Pikwg6DiIh+QkzgiIhIhoaGGpKTUvD4wcvCDkWGhWU1JCal4MGz14UdilzVq5SDlib/vBIRUcHgXxgiIpLr8YOXmD1xfWGHIWNHxHw8eP4GU722FHYoci2f7QwLs0qFHQYREf2kimb/GCIiIiIiIpLBBI6IiIiIiEhFMIEjIiIiIiJSEUzgiIiIiIiIVAQTOCIiIiIiIhXBBI6IiIiIiEhFMIEjIiIiIiJSEUzgiIiIiIiIVAQTOCIiIiIiIhXBBI6IiIiIiEhFMIEjIiIiIiJSESqTwF2+fBkDBw6ElZUVWrZsiYULFyI+Pl6yPDIyEr1794aVlRXs7e0RGBhYiNESERERERHlP5VI4K5du4Zhw4ahdOnSWLduHcaPH499+/bB3d0dABAdHQ0XFxeYmprCz88Pjo6O8Pb2RkBAQCFHTkRERERElH80CjsAZSxduhT169fHqlWrIBKJ0Lx5c6Snp2PTpk1ITEyEr68vLCws4OPjAwCwtbVFamoq/P394ezsDC0trUI+AyIiIiIiorwr8i1wHz58QFRUFAYOHAiRSCQpHzx4MI4ePQo1NTVERUWhffv2Utt16NABX758QXR09I8OmYiIiIiIqEAU+QTun3/+gSAIMDIywq+//or69eujYcOGmDdvHr59+4aYmBikpKTAxMREaruqVasCAB4/flwYYRMREREREeW7It+F8sOHDwCAWbNmwcHBAevWrcO9e/ewcuVKJCUloX///gAAfX19qe309PQAAHFxcbk6rkgEGBnpKlyuoaGeq/1SBg0N9Syvb072Q7nHz6FoyK/PISdYxxUsfreKhvz6HNTV1aR6ARUl4rAEoXDjUEQQBKSlpRd2GEQ/lSKfwKWkpAAAGjRogHnz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\n"
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "sns.catplot(x=\"index\", y=\"value\", hue=\"kind\", col=\"variable\", kind=\"bar\", data=df_reconstr_comp, height=5, aspect=1, col_wrap=2)\n",
    "plt.savefig(\"flux_set_comparison.svg\")"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "markdown",
   "id": "374a05f5-9031-4711-a578-e9d2f85e99d9",
   "metadata": {},
   "source": [
    "# Add molecularity factor"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 98,
   "outputs": [
    {
     "data": {
      "text/plain": "                             6PFRUCTPHOS-RXN  F16ALDOLASE-RXN  2TRANSKETO-RXN  \\\nFRUCTOSE-6P                               -2                0               1   \nATP                                       -2                0               0   \nPROTON                                     2                0               0   \nADP                                        2                0               0   \nFRUCTOSE-16-DIPHOSPHATE                    2               -1               0   \nDIHYDROXY-ACETONE-PHOSPHATE                0                1               0   \nGAP                                        0                1               1   \nERYTHROSE-4P                               0                0              -1   \nXYLULOSE-5-PHOSPHATE                       0                0              -1   \n\n                             TRIOSEPISOMERIZATION-RXN  \nFRUCTOSE-6P                                         0  \nATP                                                 0  \nPROTON                                              0  \nADP                                                 0  \nFRUCTOSE-16-DIPHOSPHATE                             0  \nDIHYDROXY-ACETONE-PHOSPHATE                         1  \nGAP                                                -1  \nERYTHROSE-4P                                        0  \nXYLULOSE-5-PHOSPHATE                                0  ",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>6PFRUCTPHOS-RXN</th>\n      <th>F16ALDOLASE-RXN</th>\n      <th>2TRANSKETO-RXN</th>\n      <th>TRIOSEPISOMERIZATION-RXN</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>FRUCTOSE-6P</th>\n      <td>-2</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ATP</th>\n      <td>-2</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>PROTON</th>\n      <td>2</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ADP</th>\n      <td>2</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>FRUCTOSE-16-DIPHOSPHATE</th>\n      <td>2</td>\n      <td>-1</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>DIHYDROXY-ACETONE-PHOSPHATE</th>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>GAP</th>\n      <td>0</td>\n      <td>1</td>\n      <td>1</td>\n      <td>-1</td>\n    </tr>\n    <tr>\n      <th>ERYTHROSE-4P</th>\n      <td>0</td>\n      <td>0</td>\n      <td>-1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>XYLULOSE-5-PHOSPHATE</th>\n      <td>0</td>\n      <td>0</td>\n      <td>-1</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 98,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Sd = pd.DataFrame(stoich_dict, dtype=np.int8).fillna(0).astype(np.int8)\n",
    "# Sd = Sd.iloc[0:7, 0:2]\n",
    "\n",
    "n_met = len(Sd.index)\n",
    "n_rxn = len(Sd.columns)\n",
    "\n",
    "Sd[\"6PFRUCTPHOS-RXN\"] = Sd[\"6PFRUCTPHOS-RXN\"] * 2\n",
    "Sd"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "outputs": [
    {
     "data": {
      "text/plain": "          6PFRUCTPHOS-RXN  F16ALDOLASE-RXN  2TRANSKETO-RXN  \\\n$K_{eq}$         8.491991        -8.894527        2.398769   \n$v_1$           45.000000        70.000000      -30.000000   \n$v_2$           50.000000       100.000000       30.000000   \n$v_3$           55.000000        60.000000       75.000000   \nsign 1           1.000000         1.000000       -1.000000   \nsign 2           1.000000         1.000000        1.000000   \nsign 3           1.000000         1.000000        1.000000   \n\n          TRIOSEPISOMERIZATION-RXN  \n$K_{eq}$                  2.266298  \n$v_1$                    50.000000  \n$v_2$                    50.000000  \n$v_3$                    50.000000  \nsign 1                    1.000000  \nsign 2                    1.000000  \nsign 3                    1.000000  ",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>6PFRUCTPHOS-RXN</th>\n      <th>F16ALDOLASE-RXN</th>\n      <th>2TRANSKETO-RXN</th>\n      <th>TRIOSEPISOMERIZATION-RXN</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>$K_{eq}$</th>\n      <td>8.491991</td>\n      <td>-8.894527</td>\n      <td>2.398769</td>\n      <td>2.266298</td>\n    </tr>\n    <tr>\n      <th>$v_1$</th>\n      <td>45.000000</td>\n      <td>70.000000</td>\n      <td>-30.000000</td>\n      <td>50.000000</td>\n    </tr>\n    <tr>\n      <th>$v_2$</th>\n      <td>50.000000</td>\n      <td>100.000000</td>\n      <td>30.000000</td>\n      <td>50.000000</td>\n    </tr>\n    <tr>\n      <th>$v_3$</th>\n      <td>55.000000</td>\n      <td>60.000000</td>\n      <td>75.000000</td>\n      <td>50.000000</td>\n    </tr>\n    <tr>\n      <th>sign 1</th>\n      <td>1.000000</td>\n      <td>1.000000</td>\n      <td>-1.000000</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>sign 2</th>\n      <td>1.000000</td>\n      <td>1.000000</td>\n      <td>1.000000</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>sign 3</th>\n      <td>1.000000</td>\n      <td>1.000000</td>\n      <td>1.000000</td>\n      <td>1.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 99,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "K_eq = np.log(keq)\n",
    "K_eq_mod = K_eq[:, np.newaxis].T\n",
    "vE = np.array([[90, 70, -30, 50], [100, 100, 30, 50], [110, 60, 75, 50]])\n",
    "vE[:, 0] = vE[:, 0] / 2\n",
    "\n",
    "n_flux_set = vE.shape[0]\n",
    "\n",
    "# K_eq[vE < 0] = 1/K_eq[vE < 0]\n",
    "\n",
    "lvE = np.log(np.abs(vE))\n",
    "pd.DataFrame(np.concatenate([K_eq_mod, vE, np.sign(vE, dtype=np.int8)]), columns=Sd.columns,\n",
    "             index=[\"$K_{eq}$\", \"$v_1$\", \"$v_2$\", \"$v_3$\", \"sign 1\", \"sign 2\", \"sign 3\"])"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 100,
   "outputs": [],
   "source": [
    "# set up variables\n",
    "\n",
    "S_mol = np.array(Sd)\n",
    "S = np.sign(S_mol) #\n",
    "S_s = -np.copy(S) # reverse neg sign\n",
    "S_p = np.copy(S)\n",
    "S_s[S > 0] = 0 # zeros products\n",
    "S_p[S < 0] = 0 # zeros substrates\n",
    "S_i = np.copy(np.array(Sr) == -1) # reaction direction does not matter\n",
    "S_a = np.copy(np.array(Sr) == 1)\n",
    "\n",
    "\n",
    "S_s_nz = np.array(S_s.nonzero())\n",
    "S_p_nz = np.array(S_p.nonzero())\n",
    "S_i_nz = np.array(S_i.nonzero())\n",
    "S_a_nz = np.array(S_a.nonzero())\n",
    "S_s_mol = np.abs(S_mol)[S_s.nonzero()]\n",
    "S_p_mol = np.abs(S_mol)[S_p.nonzero()]\n",
    "\n",
    "# TODO Refactor all the below lines as one liners\n",
    "# first coordinate, e.g. metabolites w nonzero substrate/product coeff across all reactions. also works as substrate indices.\n",
    "met_s_nz = S_s_nz[0, :]\n",
    "met_p_nz = S_p_nz[0, :]\n",
    "met_i_nz = S_i_nz[0, :]\n",
    "met_a_nz = S_a_nz[0, :]\n",
    "\n",
    "# second coordinate, e.g. reactions indices for those concentrations. works to index substrates as well.\n",
    "rxn_s_nz = S_s_nz[1, :]\n",
    "rxn_p_nz = S_p_nz[1, :]\n",
    "rxn_i_nz = S_i_nz[1, :]\n",
    "rxn_a_nz = S_a_nz[1, :]\n",
    "\n",
    "# one dim is always 2\n",
    "n_Km_s = np.max(met_s_nz.shape)\n",
    "n_Km_p = np.max(met_p_nz.shape)\n",
    "n_Km_i = np.max(met_i_nz.shape)\n",
    "n_Km_a = np.max(met_a_nz.shape)\n",
    "\n",
    "c = cp.Variable([n_met, n_flux_set])\n",
    "Km_s = cp.Variable(n_Km_s)\n",
    "Km_p = cp.Variable(n_Km_p)\n",
    "Km_i = cp.Variable(n_Km_i) if n_Km_i else None\n",
    "Km_a = cp.Variable(n_Km_a) if n_Km_a else None\n",
    "\n",
    "cfwd = cp.Variable(n_rxn)\n",
    "crev = cp.Variable(n_rxn)\n",
    "\n",
    "# define y vecs\n",
    "y_s_t = []\n",
    "y_p_t = []\n",
    "y_i_t = []\n",
    "y_a_t = []\n",
    "\n",
    "# define Km positions by nonzero S matrix concentrations. Activation is reverse val of inhibition.\n",
    "# TODO Add molecularity here.\n",
    "for i in range(n_flux_set):\n",
    "    y_s_t.append(cp.multiply(S_s_mol, c[met_s_nz, i] - Km_s))\n",
    "    y_p_t.append(cp.multiply(S_p_mol, c[met_p_nz, i] - Km_p))\n",
    "    y_i_t.append(c[met_i_nz, i] - Km_i if n_Km_i else None)\n",
    "    y_a_t.append(-(c[met_a_nz, i] - Km_a) if n_Km_a else None)\n",
    "\n",
    "y_s = cp.vstack(y_s_t)\n",
    "y_p = cp.vstack(y_p_t)\n",
    "y_i = cp.vstack(y_i_t)\n",
    "y_a = cp.vstack(y_a_t)\n",
    "\n",
    "# saturation stacks\n",
    "y_f_vec = [y_s]\n",
    "y_r_vec = [y_p]\n",
    "if n_Km_i:\n",
    "    y_f_vec.append(y_i)\n",
    "    y_r_vec.append(y_i)\n",
    "if n_Km_a:\n",
    "    y_f_vec.append(y_a)\n",
    "    y_r_vec.append(y_a)\n",
    "\n",
    "y_f = cp.hstack(y_f_vec)\n",
    "y_r = cp.hstack(y_r_vec)"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "outputs": [],
   "source": [
    "# number of saturation terms for sub, prod\n",
    "S_s_comb = np.concatenate((S_s, S_i, S_a), axis=0)\n",
    "S_p_comb = np.concatenate((S_p, S_i, S_a), axis=0)\n",
    "n_alpha = np.sum(np.power(2, np.sign(S_s_comb).sum(axis=0)) - 1)\n",
    "n_beta = np.sum(np.power(2, np.sign(S_p_comb).sum(axis=0)) - 1)\n",
    "\n",
    "# saturation matrix setup, first sub, then inhib, then act.\n",
    "C_alpha = np.zeros([n_alpha, len(met_s_nz) + len(met_i_nz) + len(met_a_nz)])\n",
    "C_beta = np.zeros([n_beta, len(met_p_nz) + len(met_i_nz) + len(met_a_nz)])\n",
    "\n",
    "# to separate different reactions saturation terms to their individual reaction equations.\n",
    "d_alpha = np.zeros(n_alpha, dtype=np.int8)\n",
    "d_beta = np.zeros(n_beta, dtype=np.int8)\n",
    "\n",
    "\n",
    "idx = 0\n",
    "\n",
    "for i in range(n_rxn):\n",
    "\n",
    "    # pick one reaction at a time (get substrate indicies)\n",
    "    #idx_cur_rxn = rxn_s_nz == i\n",
    "    # TODO This does not properly multiply by molecularity. Alternatively, generate C_alpha and\n",
    "    # TODO beta without molecularity (first ==1) and then multiply by molecularity in the end.\n",
    "    idx_cur_rxn = np.concatenate((rxn_s_nz == i, rxn_i_nz == i, rxn_a_nz == i))\n",
    "\n",
    "    # generates all binary permutations minus the first one since that would result in -1\n",
    "    sat_perm = np.array(list(itertools.product([0, 1], repeat=sum(idx_cur_rxn))))\n",
    "    sat_perm = sat_perm[1:, :]\n",
    "\n",
    "    r, _ = sat_perm.shape\n",
    "\n",
    "    # replace zeros with saturation matrix\n",
    "    C_alpha[idx:(idx+r), idx_cur_rxn] = sat_perm\n",
    "    d_alpha[idx:(idx+r)] = i\n",
    "\n",
    "    idx += r # add row #\n",
    "\n",
    "idx = 0\n",
    "\n",
    "for i in range(n_rxn):\n",
    "    idx_cur_rxn = np.concatenate((rxn_p_nz == i, rxn_i_nz == i, rxn_a_nz == i))\n",
    "\n",
    "    sat_perm = np.array(list(itertools.product([0, 1], repeat=sum(idx_cur_rxn))))\n",
    "    sat_perm = sat_perm[1:, :]\n",
    "\n",
    "    r, _ = sat_perm.shape\n",
    "\n",
    "    C_beta[idx:(idx+r), idx_cur_rxn] = sat_perm\n",
    "    d_beta[idx:(idx+r)] = i\n",
    "\n",
    "    idx += r # add row #"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "outputs": [
    {
     "data": {
      "text/plain": "array([[0., 0., 0., 0., 0., 0., 0., 1.],\n       [0., 0., 0., 0., 0., 0., 1., 0.],\n       [0., 0., 0., 0., 0., 0., 1., 1.],\n       [0., 1., 0., 0., 0., 0., 0., 0.],\n       [0., 1., 0., 0., 0., 0., 0., 1.],\n       [0., 1., 0., 0., 0., 0., 1., 0.],\n       [0., 1., 0., 0., 0., 0., 1., 1.],\n       [1., 0., 0., 0., 0., 0., 0., 0.],\n       [1., 0., 0., 0., 0., 0., 0., 1.],\n       [1., 0., 0., 0., 0., 0., 1., 0.],\n       [1., 0., 0., 0., 0., 0., 1., 1.],\n       [1., 1., 0., 0., 0., 0., 0., 0.],\n       [1., 1., 0., 0., 0., 0., 0., 1.],\n       [1., 1., 0., 0., 0., 0., 1., 0.],\n       [1., 1., 0., 0., 0., 0., 1., 1.],\n       [0., 0., 1., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 1., 0., 0.],\n       [0., 0., 0., 0., 1., 0., 0., 0.],\n       [0., 0., 0., 0., 1., 1., 0., 0.],\n       [0., 0., 0., 1., 0., 0., 0., 0.]])"
     },
     "execution_count": 102,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "C_alpha"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 103,
   "outputs": [
    {
     "data": {
      "text/plain": "[Expression(AFFINE, UNKNOWN, (48,)),\n Expression(AFFINE, UNKNOWN, (6,)),\n Expression(AFFINE, UNKNOWN, (8,)),\n Expression(AFFINE, UNKNOWN, (4,)),\n Expression(AFFINE, UNKNOWN, (48,)),\n Expression(AFFINE, UNKNOWN, (6,)),\n Expression(AFFINE, UNKNOWN, (8,)),\n Expression(AFFINE, UNKNOWN, (4,)),\n Expression(AFFINE, UNKNOWN, (48,)),\n Expression(AFFINE, UNKNOWN, (6,)),\n Expression(AFFINE, UNKNOWN, (8,)),\n Expression(AFFINE, UNKNOWN, (4,))]"
     },
     "execution_count": 103,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "n_lse_terms = np.max(np.power(2, S_s.sum(axis=0)) +  np.power(2, S_p.sum(axis=0)) - 2)\n",
    "LSE_expr = []\n",
    "denom_expr = []\n",
    "\n",
    "sign = np.sign(vE)\n",
    "lvE = np.log(sign * vE)\n",
    "\n",
    "for j in range(n_flux_set):\n",
    "    for i in range(n_rxn):\n",
    "        # sum terms are separate in logsumexp. one per saturation term (row in C_alpha, C_beta)\n",
    "\n",
    "        n_term_s = np.sum(d_alpha == i)\n",
    "        n_term_p = np.sum(d_beta == i)\n",
    "        n_term = n_term_s + n_term_p\n",
    "\n",
    "        Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "        S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "\n",
    "        Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "        S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "\n",
    "        if sign[j, i] == 1:\n",
    "            LSE_expr.append(cp.hstack( [\n",
    "                                         lvE[j, i] + (C_alpha @ cp.vec(y_f[j, :]))[d_alpha == i]\n",
    "                                            - cp.multiply(np.ones(n_term_s), - S.T[i, S_s_idx] @ cp.vec(y_s[j, Km_s_idx])) - cfwd[i],\n",
    "                                         lvE[j, i] + (C_beta @ cp.vec(y_r[j, :]))[d_beta == i]\n",
    "                                            - cp.multiply(np.ones(n_term_p), - S.T[i, S_s_idx] @ cp.vec(y_s[j, Km_s_idx])) - cfwd[i],\n",
    "\n",
    "                                         lvE[j, i] + 0 - cp.multiply(np.ones(1), -S.T[i, S_s_idx] @ cp.vec(y_s[j, Km_s_idx]))  - cfwd[i],\n",
    "\n",
    "                                         cp.multiply(np.ones(1), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx]))  + crev[i]\n",
    "                                            - cp.multiply(np.ones(1), -S.T[i, S_s_idx] @ cp.vec(y_s[j, Km_s_idx]))  - cfwd[i],\n",
    "\n",
    "                                       ]\n",
    "                                     )\n",
    "                           )  # remove +1 here, could also have cfwd outside objec.\n",
    "\n",
    "            denom_expr.append(cp.multiply(np.ones(1), -S.T[i, S_s_idx] @ cp.vec(y_s[j, Km_s_idx])) + cfwd[i],)\n",
    "\n",
    "\n",
    "        # keep saturation term the same, switch around fwd and rev terms. flip all signs with S matrix since it's signed.\n",
    "        if sign[j, i] == -1:\n",
    "            LSE_expr.append(cp.hstack( [ lvE[j, i] + (C_alpha @ cp.vec(y_f[j, :]))[d_alpha == i]\n",
    "                                            - cp.multiply(np.ones(n_term_s), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx])) - crev[i],\n",
    "\n",
    "                                         lvE[j, i] + (C_beta @ cp.vec(y_r[j, :]))[d_beta == i]\n",
    "                                            - cp.multiply(np.ones(n_term_p), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx])) - crev[i],\n",
    "\n",
    "                                         lvE[j, i] + 0 - cp.multiply(np.ones(1), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx])) - crev[i],\n",
    "\n",
    "                                         cp.multiply(np.ones(1), - S.T[i, S_s_idx] @ cp.vec(y_s[j, Km_s_idx]))  + cfwd[i]\n",
    "                                            - cp.multiply(np.ones(1), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx])) - crev[i],\n",
    "\n",
    "                                       ]\n",
    "                                     )\n",
    "                           )\n",
    "\n",
    "            denom_expr.append(cp.multiply(np.ones(1), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx])) + crev[i])\n",
    "\n",
    "\n",
    "#LSE_expr = cp.vstack(LSE_expr)\n",
    "LSE_expr"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 104,
   "outputs": [],
   "source": [
    "l = 0.001\n",
    "e = 0.001\n",
    "f = 0.000001\n",
    "reg =  cp.sum(cp.hstack([cfwd, crev, cp.vec(c)])) + cp.sum(cp.hstack([-Km_s, -Km_p])) # regularization\n",
    "reg2 = cp.norm1(cp.hstack([cfwd, crev, cp.vec(c)])) + cp.norm1(cp.hstack([-Km_s, -Km_p])) # regularization\n",
    "reg3 = cp.sum(cp.huber(cp.hstack([y_s, y_p]), 1)) # issue with matrix\n",
    "\n",
    "if n_Km_i:\n",
    "    reg += cp.sum(cp.hstack([-Km_i]))\n",
    "if n_Km_a:\n",
    "    reg += cp.sum(cp.hstack([-Km_a]))\n",
    "#reg3 = cp.norm1(cp.hstack([y_s, y_p])) # take a look at this\n",
    "\n",
    "loss = 0\n",
    "for i in range(len(LSE_expr)):\n",
    "    loss += cp.norm1(cp.pos(cp.log_sum_exp(LSE_expr[i])))\n",
    "for i in range(len(denom_expr)):\n",
    "    loss += 0.01 * denom_expr[i]\n",
    "loss += l * reg\n",
    "loss += e * reg2\n",
    "loss += f * reg3\n",
    "#"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 105,
   "outputs": [],
   "source": [
    "constr = [cp.hstack([cfwd, crev, cp.vec(c), Km_s, Km_p]) >= -12,\n",
    "          cp.hstack([cfwd, crev, cp.vec(c), Km_s, Km_p]) <= 12,\n",
    "          ]\n",
    "\n",
    "if n_Km_i:\n",
    "    constr.extend([Km_i >= -12, Km_i <= 12])\n",
    "if n_Km_a:\n",
    "    constr.extend([Km_a >= -12, Km_a <= 12])\n",
    "\n"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "outputs": [],
   "source": [
    "haldane = []\n",
    "fwd_flux = []\n",
    "\n",
    "for i, r in enumerate(S.T):\n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "\n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "\n",
    "    haldane.append(K_eq[i] == cfwd[i] - crev[i] + r[S_p_idx] @ Km_p[Km_p_idx] - (-r[S_s_idx]) @ Km_s[Km_s_idx])\n",
    "\n",
    "for j in range(n_flux_set):\n",
    "    for i, r in enumerate(S.T):\n",
    "        Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "        S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "\n",
    "        Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "        S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "\n",
    "        if sign[j, i] == 1:\n",
    "            fwd_flux.append(cfwd[i] + (-r[S_s_idx]) @ cp.vec(y_s[j, Km_s_idx]) - (crev[i] + r[S_p_idx] @ cp.vec(y_p[j, Km_p_idx]))  >= 0)  # add minus since s matrix has minus\n",
    "\n",
    "        if sign[j, i] == -1:\n",
    "            fwd_flux.append(cfwd[i] + (-r[S_s_idx]) @ cp.vec(y_s[j, Km_s_idx]) - (crev[i] + r[S_p_idx] @ cp.vec(y_p[j, Km_p_idx]))  <= 0)  # add minus since s matrix has minus\n",
    "\n",
    "    constr.extend([cp.multiply(S.T @ cp.vec(c[:, j]), sign[j, :])  <= cp.multiply(K_eq, sign[j, :])])\n",
    "\n",
    "constr.extend(haldane)\n",
    "constr.extend(fwd_flux)"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'cp' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001B[0;31m---------------------------------------------------------------------------\u001B[0m",
      "\u001B[0;31mNameError\u001B[0m                                 Traceback (most recent call last)",
      "\u001B[0;32m/var/folders/dx/0239zgvj0tgf46b5h8l7v_fc0000gn/T/ipykernel_17564/1077725836.py\u001B[0m in \u001B[0;36m<module>\u001B[0;34m\u001B[0m\n\u001B[0;32m----> 1\u001B[0;31m \u001B[0mp\u001B[0m \u001B[0;34m=\u001B[0m \u001B[0mcp\u001B[0m\u001B[0;34m.\u001B[0m\u001B[0mProblem\u001B[0m\u001B[0;34m(\u001B[0m\u001B[0mcp\u001B[0m\u001B[0;34m.\u001B[0m\u001B[0mMinimize\u001B[0m\u001B[0;34m(\u001B[0m\u001B[0mloss\u001B[0m\u001B[0;34m)\u001B[0m\u001B[0;34m,\u001B[0m \u001B[0mconstr\u001B[0m\u001B[0;34m)\u001B[0m\u001B[0;34m\u001B[0m\u001B[0;34m\u001B[0m\u001B[0m\n\u001B[0m\u001B[1;32m      2\u001B[0m \u001B[0mp\u001B[0m\u001B[0;34m.\u001B[0m\u001B[0msolve\u001B[0m\u001B[0;34m(\u001B[0m\u001B[0mverbose\u001B[0m\u001B[0;34m=\u001B[0m\u001B[0;32mTrue\u001B[0m\u001B[0;34m,\u001B[0m \u001B[0msolver\u001B[0m\u001B[0;34m=\u001B[0m\u001B[0mcp\u001B[0m\u001B[0;34m.\u001B[0m\u001B[0mECOS\u001B[0m\u001B[0;34m)\u001B[0m\u001B[0;34m\u001B[0m\u001B[0;34m\u001B[0m\u001B[0m\n",
      "\u001B[0;31mNameError\u001B[0m: name 'cp' is not defined"
     ]
    }
   ],
   "source": [
    "p = cp.Problem(cp.Minimize(loss), constr)\n",
    "p.solve(verbose=True, solver=cp.ECOS)"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 109,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Substrate Km: ['15.405', '2.714', '11.473', '1.058', '2.456', '2.456']\n",
      "Product Km: ['74.476', '1.000', '2.224', '5.490', '0.033', '0.033', '1.000', '1.000']\n",
      "Fwd kcat: ['16691.733', '1327.604', '4687.099', '847.466']\n",
      "Rev kcat: ['1.000', '27643.302', '5257.662', '2.720']\n",
      "Concentration: ['7.5190', '0.3478', '0.0161', '0.3199', '0.6842', '0.0000', '0.0664', '0.0004', '0.0004']\n",
      "Concentration: ['2.8601', '1.0000', '0.0148', '0.3148', '1.0000', '0.0000', '0.0664', '0.2620', '0.2620']\n",
      "Concentration: ['3.0064', '0.9850', '0.0152', '0.3160', '0.5823', '0.0000', '0.0664', '0.3988', '0.3988']\n",
      "Activation Km: ['0.368', '0.006']\n"
     ]
    }
   ],
   "source": [
    "print('Substrate Km:', [f'{val:.3f}' for val in np.exp(Km_s.value)])\n",
    "print('Product Km:', [f'{val:.3f}' for val in np.exp(Km_p.value)])\n",
    "print('Fwd kcat:', [f'{val:.3f}' for val in np.exp(cfwd.value)])\n",
    "print('Rev kcat:', [f'{val:.3f}' for val in np.exp(crev.value)])\n",
    "\n",
    "concs = np.exp(c.value).T\n",
    "for row in concs:\n",
    "    print('Concentration:', [f'{val:.4f}' for val in row])\n",
    "\n",
    "if n_Km_i:\n",
    "    print('Inhibition Km:', [f'{val:.3f}' for val in np.exp(Km_i.value)])\n",
    "if n_Km_a:\n",
    "    print('Activation Km:', [f'{val:.3f}' for val in np.exp(Km_a.value)])"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 110,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "-3.888018841324836e-07\n",
      "-6.322530571312157e-08\n",
      "-4.755855434468437e-08\n",
      "-7.837918723774262e-08\n",
      "-3.510083170232825e-07\n",
      "-5.385769247245875e-08\n",
      "-8.229559989025859e-08\n",
      "-3.262754130067824e-08\n",
      "-3.623455192558467e-07\n",
      "-6.395986819340838e-08\n",
      "-7.819181951917997e-08\n",
      "-3.6317813326136594e-08\n"
     ]
    }
   ],
   "source": [
    "for v in LSE_expr:\n",
    "    #print(v.value)\n",
    "    print(logsumexp(v.value))"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "Perfect? Wow."
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "# Check flux reconstruction with inhibition/activation"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 111,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 45.0000175   70.00000445 -30.00000143  50.00000392]\n",
      "[ 50.00001755 100.0000054   30.0000033   50.00000163]\n",
      "[55.00001993 60.00000386 75.00000662 50.00000182]\n"
     ]
    }
   ],
   "source": [
    "reconstructed_vE = np.zeros(vE.shape)\n",
    "\n",
    "for j in range(n_flux_set):\n",
    "    sat_expr = []\n",
    "    fwd_sat = np.zeros(n_rxn)\n",
    "    back_sat = np.zeros(n_rxn)\n",
    "    sat = np.zeros(n_rxn)\n",
    "\n",
    "    for i in range(n_rxn):\n",
    "        # sum terms are separate in logsumexp. one per saturation term (row in C_alpha, C_beta)\n",
    "        n_term_s = np.sum(d_alpha == i)\n",
    "        n_term_p = np.sum(d_beta == i)\n",
    "        n_term = n_term_s + n_term_p\n",
    "\n",
    "\n",
    "        Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "        S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "\n",
    "        Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "        S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "\n",
    "        #S_s_idx = S_s_nz[0, S_s_nz[1, :] == i]\n",
    "\n",
    "        sat_expr.append(           [ (C_alpha @ y_f.value[j, :].flatten())[d_alpha == i] ,\n",
    "                                     (C_beta @ y_r.value[j, :].flatten())[d_beta == i],\n",
    "                                     0,\n",
    "                                     #-1*np.ones(n_lse_terms - n_term + 1)\n",
    "                                   ]\n",
    "                       )\n",
    "        fwd_sat[i] = (np.exp(-S.T[i, S_s_idx] @ y_s.value[j, Km_s_idx].flatten())) # + cfwd.value[i]\n",
    "        back_sat[i] = (np.exp(S.T[i, S_p_idx] @ y_p.value[j, Km_p_idx].flatten())) # + cfwd.value[i]\n",
    "\n",
    "\n",
    "\n",
    "    for i, rxn in enumerate(sat_expr):\n",
    "        s = 0\n",
    "\n",
    "        for term in rxn:\n",
    "            s += np.sum(np.exp(term))\n",
    "\n",
    "        sat[i] = (s)\n",
    "\n",
    "    reconstr = np.exp(cfwd.value) * fwd_sat/sat - np.exp(crev.value) * back_sat/sat\n",
    "    print(reconstr)\n",
    "    reconstructed_vE[j, :] = reconstr"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 112,
   "outputs": [
    {
     "data": {
      "text/plain": "         index                  variable       value                kind\n0   Flux set 1           6PFRUCTPHOS-RXN   45.000000         Actual flux\n1   Flux set 2           6PFRUCTPHOS-RXN   50.000000         Actual flux\n2   Flux set 3           6PFRUCTPHOS-RXN   55.000000         Actual flux\n3   Flux set 1           F16ALDOLASE-RXN   70.000000         Actual flux\n4   Flux set 2           F16ALDOLASE-RXN  100.000000         Actual flux\n5   Flux set 3           F16ALDOLASE-RXN   60.000000         Actual flux\n6   Flux set 1            2TRANSKETO-RXN  -30.000000         Actual flux\n7   Flux set 2            2TRANSKETO-RXN   30.000000         Actual flux\n8   Flux set 3            2TRANSKETO-RXN   75.000000         Actual flux\n9   Flux set 1  TRIOSEPISOMERIZATION-RXN   50.000000         Actual flux\n10  Flux set 2  TRIOSEPISOMERIZATION-RXN   50.000000         Actual flux\n11  Flux set 3  TRIOSEPISOMERIZATION-RXN   50.000000         Actual flux\n12  Flux set 1           6PFRUCTPHOS-RXN   45.000017  Reconstructed flux\n13  Flux set 2           6PFRUCTPHOS-RXN   50.000018  Reconstructed flux\n14  Flux set 3           6PFRUCTPHOS-RXN   55.000020  Reconstructed flux\n15  Flux set 1           F16ALDOLASE-RXN   70.000004  Reconstructed flux\n16  Flux set 2           F16ALDOLASE-RXN  100.000005  Reconstructed flux\n17  Flux set 3           F16ALDOLASE-RXN   60.000004  Reconstructed flux\n18  Flux set 1            2TRANSKETO-RXN  -30.000001  Reconstructed flux\n19  Flux set 2            2TRANSKETO-RXN   30.000003  Reconstructed flux\n20  Flux set 3            2TRANSKETO-RXN   75.000007  Reconstructed flux\n21  Flux set 1  TRIOSEPISOMERIZATION-RXN   50.000004  Reconstructed flux\n22  Flux set 2  TRIOSEPISOMERIZATION-RXN   50.000002  Reconstructed flux\n23  Flux set 3  TRIOSEPISOMERIZATION-RXN   50.000002  Reconstructed flux",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>index</th>\n      <th>variable</th>\n      <th>value</th>\n      <th>kind</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Flux set 1</td>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>45.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Flux set 2</td>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>50.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Flux set 3</td>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>55.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Flux set 1</td>\n      <td>F16ALDOLASE-RXN</td>\n      <td>70.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Flux set 2</td>\n      <td>F16ALDOLASE-RXN</td>\n      <td>100.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>Flux set 3</td>\n      <td>F16ALDOLASE-RXN</td>\n      <td>60.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>Flux set 1</td>\n      <td>2TRANSKETO-RXN</td>\n      <td>-30.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>Flux set 2</td>\n      <td>2TRANSKETO-RXN</td>\n      <td>30.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>Flux set 3</td>\n      <td>2TRANSKETO-RXN</td>\n      <td>75.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>Flux set 1</td>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>50.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>Flux set 2</td>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>50.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>Flux set 3</td>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>50.000000</td>\n      <td>Actual flux</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>Flux set 1</td>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>45.000017</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>Flux set 2</td>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>50.000018</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>14</th>\n      <td>Flux set 3</td>\n      <td>6PFRUCTPHOS-RXN</td>\n      <td>55.000020</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>15</th>\n      <td>Flux set 1</td>\n      <td>F16ALDOLASE-RXN</td>\n      <td>70.000004</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>16</th>\n      <td>Flux set 2</td>\n      <td>F16ALDOLASE-RXN</td>\n      <td>100.000005</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>17</th>\n      <td>Flux set 3</td>\n      <td>F16ALDOLASE-RXN</td>\n      <td>60.000004</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>18</th>\n      <td>Flux set 1</td>\n      <td>2TRANSKETO-RXN</td>\n      <td>-30.000001</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>19</th>\n      <td>Flux set 2</td>\n      <td>2TRANSKETO-RXN</td>\n      <td>30.000003</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>20</th>\n      <td>Flux set 3</td>\n      <td>2TRANSKETO-RXN</td>\n      <td>75.000007</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>21</th>\n      <td>Flux set 1</td>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>50.000004</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>22</th>\n      <td>Flux set 2</td>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>50.000002</td>\n      <td>Reconstructed flux</td>\n    </tr>\n    <tr>\n      <th>23</th>\n      <td>Flux set 3</td>\n      <td>TRIOSEPISOMERIZATION-RXN</td>\n      <td>50.000002</td>\n      <td>Reconstructed flux</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 112,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df_vE = pd.DataFrame(vE, columns=Sd.columns, index=[\"Flux set 1\", \"Flux set 2\", \"Flux set 3\"]).melt(ignore_index=False).reset_index(drop=False)\n",
    "df_vE[\"kind\"] = \"Actual flux\"\n",
    "df_recon = pd.DataFrame(reconstructed_vE, columns=Sd.columns, index=[\"Flux set 1\", \"Flux set 2\", \"Flux set 3\"]).melt(ignore_index=False).reset_index(drop=False)\n",
    "df_recon[\"kind\"] = \"Reconstructed flux\"\n",
    "\n",
    "df_reconstr_comp = pd.concat([df_vE, df_recon]).reset_index(drop=True)\n",
    "df_reconstr_comp"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 113,
   "outputs": [
    {
     "data": {
      "text/plain": "<Figure size 916.4x720 with 4 Axes>",
      "image/png": "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GYVI4IYPH45z584hIiIC8fHxOHz4ME6fPg17e3vExsYiNTUVhoaGEtvUrFkTABATE1McIRMRERERERU6hehC2aNHD1y6dAm///67uKxPnz4YM2YMrl+/DgDQ0dGR2EbUYhcfH5+vYyopAfr6WvkLmIiohGMdpxhUVVWKOwSFpqqqwt9zIvrlKEQCN2HCBFy/fh3z5s2DmZkZbt68iY0bN0JHRwfdu3fPdltlZYVoZCQiIiIiIspRiU/goqOjERkZCQ8PD/Tt2xcA0KxZM+jp6WHBggXo378/ACAhIUFiO1HLm66ubr6OKwjAly9JBYiciKjwlC+fv7pMHtZxioGtRwWTlpbO33MFUdh1HNGvrMQ3T7169QoA0LhxY4lyKysrAMD9+/ehoqKC58+fSywX/Zx1bBwREREREZGiKvEJnCgBu3btmkT5jRs3AABGRkawsrLC0aNHIQiCePmRI0egq6uLBg0a/LRYiYiIiIiIilKJ70JZv359dOrUCe7u7vj27Rvq1auHO3fuYMOGDWjXrh0sLCwwYcIEjBw5EtOnT0efPn1w/fp1+Pv7Y+bMmdDSYvcTIiIiIiL6NZT4BA4A1qxZg/Xr1+Ovv/5CXFwcqlatilGjRmHcuHEAgJYtW8LHxwfe3t6YNGkSKlasiNmzZ2PUqFHFHDkREREREVHhUYgETl1dHTNmzMCMGTPkrmNrawtbW9ufGBUREREREdHPVeLHwBEREREREVEmJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCBUizsAIiIqebS1NaCqWjKf8amoZMaVnp5RzJHIl5aWgYSE5OIOg4iIfkFM4IiISIqqqjJSklMR8+hVcYcixcy8FpKSU/Ho+ZviDkWm2jUqQV2Nf16JiKho8C8MERHJFPPoFeZN2VzcYUgJiliERy/eYobH9uIORabV8xxhZlytuMMgIqJfVMnsH0NERERERERSmMAREREREREpCCZwRERERERECoIJHBERERERkYJgAkdERERERKQgmMAREREREREpCCZwRERERERECoIJHBERERERkYJgAkdERERERKQgmMAREREREREpCCZwRERE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IiKSTW4CJ2/MGxERERERERUPuQkcx7wRERERERGVLIU6Bu7jx4+FuTsiIiIiIiL6Qa5noQSAXbt24dy5c0hMTERGRoa4PD09HQkJCXj06BHu3LlT6EESERERERFRHhK4P//8E6tWrYK6ujp0dHTw6dMnVKpUCZ8/f0ZSUhI0NTXh6OhYlLESERERERH9p+W6C2VISAjq1auHCxcuIDg4GIIgIDAwEFFRUViwYAGSk5NhYWFRlLESERERERH9p+U6gXv58iXs7e2ho6OD6tWrQ19fH1FRUVBRUcHQoUPRvXt3vkKAiIiIiIioCOU6gVNVVYW2trb455o1a+LBgwfin5s3b46nT58WanBERERERET0f3KdwBkbG+P69evinw0NDSUmLPny5QtSUlIKNzoiIiIiIiISy3UC17dvX4SEhMDZ2RmJiYmwsbFBVFQU1q9fj/DwcGzbtg1169YtyliJiIiIiIj+03I9C+WQIUPw5s0b7Ny5E6qqqujcuTM6dOiA9evXAwB0dHTg7OxcZIESERERERH91+U6gZs/fz7s7OwwefJkqKmpAQB8fX0RFRWFz58/w9LSEmXLli2yQImIiIiIiP7rcp3AHTp0CCEhIahQoQJ69OiBnj17wszMDFZWVkUZHxEREREREf1/uR4Dd/HiRaxatQrm5ubYuXMn+vXrh+7du8PX1xexsbFFGSMREREREREhDy1wWlpa6N69O7p37474+HgcP34cERER2LBhA9atWwcLCwvY2dlh2LBhRRkvERERERHRf1auW+B+pKOjg969e2Pz5s0IDw9H+/btcePGDSxdurSw4yMiIiIiIqL/L9ctcD/6+PEjjh07hoiICERFRSE9PR1NmzZFr169Cjs+IiIiIiIi+v9yncB9+vQJR48exeHDh3H16lWkpaXB1NQUv//+O3r27IlKlSoVZZxERERERET/eblO4Nq0aYOMjAxUrlwZo0ePhp2dHWrXrl2UsREREREREdEPcp3ADRgwAHZ2dmjSpElRxkNERERERERy5DqBc3NzK8IwiIiIiIiIKCf5moXyZ8rIyMCuXbtgZ2cHS0tLdOrUCR4eHoiPjxevc/v2bTg6OsLS0hJt2rTB6tWrkZqaWoxRExERERERFb58zUL5M23ZsgVr167F6NGj0bJlS8TExMDb2xuPHj2Cv78/nj17ht9++w2WlpZYu3YtHj9+jDVr1iA+Ph4LFiwo7vCJiIiIiIgKTYlO4ARBwJYtWzBo0CDMnDkTANCqVSuUKVMG06dPx/3797Fjxw7o6upi48aNUFdXR/v27aGpqYmlS5di/PjxqFixYjGfBRERERERUeEo0V0oExIS0KtXL/Ts2VOi3MjICADw/PlznD9/HtbW1lBXVxcv79q1K9LT0xEZGflT4yUiIiIiIipKJboFTkdHB66urlLlx48fBwAYGxvj9evXMDQ0lFhuYGAAHR0dxMTE/JQ4iYiIiIiIfoYSncDJcvPmTfj5+aFTp07Q09MDkJnoZaWtrS0x0UleKSkB+vpacperqqrke9+Uef2yu7552Q/lHz+HkqGwPoe8YB1XtPjdKhn4ORS/4qjfiH51JboLZVbXrl3DmDFjUK1aNSxduhSCIGS7vrKyQp0eERERERFRthSmBS48PBxz585FrVq1sGXLFpQpUwYJCQkAIP7vj+Lj46Grq5vv4wkC8OVLktzlfJpUMGlp6dle39zi51Aw/BxKhtx8DuXL578+k4V1XNHid6tk4OdQ/HL7GRR2HUf0K1OIJqqtW7dixowZaNSoEXbu3IkKFSoAyOwmWbFiRTx79kxi/bi4OCQkJEiNjSMiIiIiIlJkJT6B27NnD5YvX45u3bphy5YtUq1qrVu3xqlTp5CSkiIuO3LkCFRUVNCsWbOfHS4REREREVGRKdFdKOPi4uDu7o6qVati2LBhuHfvnsTyGjVqYMyYMTh06BDGjRuHESNG4OnTp1i9ejUGDhyIKlWqFFPkREREREREha9EJ3Dnzp1DUlISXr58iWHDhkkt9/T0hL29PQICAuDp6YmpU6eiTJkyGDlyJKZMmVIMERMRERERERWdEp3A9e7dG717985xPSsrK+zevbvoAyIiIiIiIipGJX4MHBEREREREWViAkdERERERKQgmMAREREREREpCCZwRERERERECoIJHBERERERkYJgAkdERERERKQgmMAREREREREpCCZwRERERERECoIJHBERERERkYJgAkdERERERKQgmMAREREREREpCCZwRERERERECoIJHBERERERkYJgAkdERERERKQgmMAREREREREpCCZwRERERERECoIJHBERERERkYJgAkdERERERKQgmMAREREREREpCCZwRERERERECoIJHBERERERkYJgAkdERERERKQgmMAREREREREpCCZwRERERERECoIJHBERERERkYJgAkdERERERKQgmMAREREREREpiF8qgQsLC0OPHj3QsGFDdOvWDfv27SvukIiIiIiIiArNL5PAhYeHw9nZGW3atMGGDRvQrFkzzJkzB4cPHy7u0IiIiIiIiAqFanEHUFjWrFmDbt26Yd68eQCAtm3b4suXL1i3bh26du1azNEREREREREV3C/RAhcbG4vnz5+jc+fOEuVdunTBkydPEBsbW0yRERERERERFZ5fIoF78uQJAMDQ0FCivGbNmgCAmJiYnx4TERERERFRYVMSBEEo7iAKKiwsDDNnzsSJEydQrVo1cfmzZ8/QuXNnrFmzBt27d8/TPgVBQGpqutzlqqoqSEz4jphHr/Idd1EyM6+FpORUPHr+prhDkVK7RiWU0tJAWpr865tb/Bzy77/yOZTkzwDI/eegrl64Pd4VuY77VT7T3ODnkH/8HIpfXj6Dwq7jiH5lv8S3JaccVFm58BsaBUFAKW1N1LcwKvR9FwYlJUC7lAYamtYs7lBkKqznBvwcCua/8DmU9M8AKLzPoTDxMy0YfrdKBn4Oxa8k1m9Eiu6XSOB0dXUBAAkJCRLl8fHxEsvzQhCAL1+SCh4cEVEhKF8+7/VYdljHEVFJUth1HNGv7JcYAyca+/b8+XOJ8mfPnkksJyIiIiIiUmS/RAJXs2ZNVKtWTeqdb0ePHkWtWrVQpUqVYoqMiIiIiIio8PwSXSgBYNKkSZg3bx709fXRoUMHnDhxAhEREVizZk1xh0ZERERERFQofpkErm/fvkhJSUFAQAD27NmD6tWrY8WKFXmefZKIiIiIiKik+iVeI1AUMjIExMXFF3cYREQACn+AP+s4IipJOIkJUe79EmPgiIiIiIiI/guYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKosQncO/fv4erqyusra1haWmJvn37IiIiQmq9bdu2wdbWFg0bNkSfPn1w5syZYoiWiIiIiIio6JToBC4lJQVjxozBhQsXMHXqVKxfvx4NGjTA77//jrCwMPF6W7ZswYoVK9CnTx/4+PigevXqmDhxIm7cuFF8wRMRERERERUyJUEQhOIOQp7jx49j0qRJ2LNnDxo2bCguHzNmDN6/f4/9+/cjMTER7dq1w+DBg+Hs7AwAEAQBgwcPhq6uLrZs2ZKvY2dkCIiLiy+U8yAiKqjy5XULdX+s44ioJCnsOo7oV1aiW+C0tbUxaNAgmJubS5QbGRnh+fPnAICbN2/i27dv6Ny5s3i5kpISbG1tcfHiRaSkpPzUmImIiIiIiIqKanEHkJ2WLVuiZcuWEmWpqak4c+YM6tSpAwB48uQJgMyk7kc1a9ZEWloaYmNjYWxs/HMCJiIiIiIiKkLFlsClpaVhz549cpdXqFABHTt2lCr38vLC06dPsWHDBgBAfHxmFyBtbW2J9UQ/JyQk5Cs+JSVAX18rX9sSEZV0rOOIiIgUU7ElcMnJyXBzc5O7vFmzZhIJnCAI8PLywrZt2zB69Gh06tRJXJ4dJSWlQomXiIiIiIiouBVbAqetrY0HDx7kat2UlBTMnTsXhw4dwujRozF79mzxMl3dzEGvCQkJ0NHREZeLWuZEy/NKEIAvX5LytS0RUWEr7AH+rOOIqCThJCZEuVeiJzEBMhOxkSNHIiIiAi4uLhLJGwAYGhoCgHhSE5Fnz55BXV0dVapU+WmxEhERERERFaUSncClp6djwoQJuHnzJtasWYMRI0ZIrWNpaYlSpUrhyJEj4jJBEHDs2DE0bdoU6urqPzNkIiIiIiKiIlOiZ6EMCgrClStXMGjQIFSqVEnixdxKSkqwsLCAlpYWRo0ahY0bN0JFRQUWFhbYu3cv7t69i8DAwOILnoiIiIiIqJCV6Bd5Dx8+HJcvX5a5TEVFBffu3QMAZGRkwNfXF7t378bHjx9Ru3ZtTJs2De3bt8/3sfmSWyIqSfgibyL6lXEMHFHulegErjjx5oaIShImcET0K2MCR5R7JXoMHBEREREREf0fJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJnBEREREREQKggkcERERERGRgmACR0REREREpCCYwBERERERESkIJUEQhOIOoiQSBAG8MkRUUigrKxXq/ljHEVFJUth1HNGvjAkcERERERGRgmAXSiIiIiIiIgXBBI6IiIiIiEhBMIEjIiIiIvpFODo6wsbGRu7yuXPnwtTUtNCOV9j7o5ypFncARERERET0cwwaNAgtW7Ys7jCoAJjAERERERH9R1haWsLS0rK4w6ACYBdKIiIiIiIiBcEEjoiIiIjoF5WQkIABAwbA0tISUVFRUmPW5s6di65du+LWrVtwcHCAhYUFWrVqhaVLl+L79+8S+7pz5w5GjRoFS0tLtG3bFps3bwbfSPbzsQslEREREdEvKCUlBZMnT8aDBw+wefNmWFlZ4Z9//pFa7+PHjxg9ejS6deuGXr164ezZs9i+fTvU1dUxe/ZsAMDDhw/h6OgIPT09TJw4EampqQgICEBKSsrPPq3/PCZwRERERES/mIyMDDg7O+Pq1avYsGFDthOXfPnyBa6urnB0dAQADBw4EN27d8fBgwfFCZyPjw8AICgoCJUrVwYAdOnSBb179y7aEyEp7EJJRERERPSLWbhwIY4cOYIlS5agffv2Oa7frVs3iZ/r1q2LDx8+AMhMBs+dO4f27duLkzcAMDY2Rps2bQo3cMoREzgiIiIiol/Iy5cvsWfPHgBAdHR0rrYxMDCQ+FldXR0ZGRkAgM+fPyMxMRE1atSQ2s7IyKiA0VJeMYEjIiIiIvqFKCkpYdGiRbC3t8eePXtw7dq1HLdRVs45Lcg6qQkAcZJHPw8TOCIiIiKiX0iVKlUwaNAgzJ49Gzo6Oli4cCFSU1Pzvb8yZcpAR0cHz549k1r24sWLgoRK+cAEjoiIiIjoF1SuXDlMnToVDx8+REBAQL73o6SkBFtbW5w7dw4PHz4Ul7948QKnT58uhEgpL5jAERERERH9ooYNG4a6deti48aNiI2Nzfd+pk2bBj09PTg4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tNCqVSs4OzujQoUKuY6vdevWWL16NbZs2SKeuMTKygqBgYHQ09MDAAwdOhQ3b97E2LFj4enpKXdsXr9+/fD8+XOEhoZi165daNq0Kby9vTFkyBDxOg0aNMC2bduwZs0aTJs2DXp6erCxscHMmTOhrKyMUqVKYeTIkQgKCsLZs2dx/vx5tG/fHlu2bMH69esxZcoUaGhowNzcHIGBgTAxMQGQ2YVy165dcHd3x5w5c6CtrY0xY8YgPDw8z5/Zj/T09ODj44NVq1Zh0qRJqFq1KiZPnixOTDMyMjBv3jyUKVMG06dPBwCoqalh0aJFGDp0qPi1B/mhJPz4gjUSy8gQEBcXX9xhEBEBAMqX1y3U/bGOI6KSpLDrOKJfGcfAERERERERKQgmcERERERERAqCCRwREREREZGCYAJHRERERESkIJjAERERERERKQgmcERERERERAqCCRwREREREZGCYAJHRERERESkIJjAERERERERKQgmcERERERERAqCCRwREREREZGCYAJHRERERESkIJjAERERERERKQgmcERERERERAqCCRwREREREZGCYAJHRERERESkIJjAERERERERKQgmcERERERERAqCCRwREREREZGCYAJHRERERESkIJjAERERERERKQgmcERERERERApCYRK4Xbt2oVu3bmjUqBHs7Oxw4MABieWRkZHo168fLCwsYGNjg4CAgGKKlIiIiIiIqGgoRAIXHBwMNzc3dOjQARs3bkSrVq0wa9YsREREAACio6Ph5OQEIyMj+Pj4wM7ODp6envD39y/myImIiIiIiAqPkiAIQnEHkZPBgwdDXV0dgYGB4rJhw4ZBWVkZ27dvx2+//YbExETs3r1bvNzLywu7d+/G+fPnoa6unudjZmQIiIuLL5T4iYgKqnx53ULdH+s4IipJCruOI/qVKUQLXHJyMrS1tSXKSpcujc+fPyM5ORlRUVHo3LmzxPIuXbrg69eviI6O/pmhEhERERERFRnV4g4gN4YPH44//vgDERERaNu2LSIjI3H69GlMnz4dsbGxSE1NhaGhocQ2NWvWBADExMSgRYsWeT6mkhKgr69VKPETEZU0rOOIiIgUk0IkcD169MClS5fw+++/i8v69OmDMWPG4Pr16wAAHR0diW1ELXbx8ewiREREREREvwaFSOAmTJiA69evY968eTAzM8PNmzexceNG6OjooHv37tluq6ycv16iggB8+ZKUr22JiApbYY8PYR1HRCUJx8AR5V6JT+Cio6MRGRkJDw8P9O3bFwDQrFkz6OnpYcGCBejfvz8AICEhQWI7Ucubri4rBCIiIiIi+jWU+ElMXr16BQBo3LixRLmVlRUA4P79+1BRUcHz588llot+zjo2joiIiIiISFGV+AROlIBdu3ZNovzGjRsAACMjI1hZWeHo0aP48Y0IR44cga6uLho0aPDTYiUiIiIiIipKJb4LZf369dGpUye4u7vj27dvqFevHu7cuYMNGzagXbt2sLCwwIQJEzBy5EhMnz4dffr0wfXr1+Hv74+ZM2dCS4uzrBERERER0a9BIV7knZKSgvXr1+PAgQOIi4tD1apV0bNnT4wbN078ku5jx47B29sbMTExqFixIoYNG4ZRo0bl+5h8yS0RlSR8kTcR/co4iQlR7ilEAlcceHNDRCUJEzgi+pUxgSPKvRI/Bo6IiIiIiIgylfgxcERU8mlra0BVtWQ+D1JRyYwrPT2jmCORLy0tAwkJycUdBhERESkAJnBEVGCqqspISU5FzKNXxR2KFDPzWkhKTsWj52+KOxSZateoBHU1VsVERESUO7xrIKJCEfPoFeZN2VzcYUgJiliERy/eYobH9uIORabV8xxhZlytuMMgIiIiBVEy+zwRERERERGRFCZwRERERERECoIJHBERERERkYJgAkdERERERKQgmMAREREREREpCCZwRERERERECoIJHBERERERkYJgAkdERERERKQgmMAREREREREpCCZwRERERERECoIJHBERERERkYJgAkdERERERKQgmMAREREREREpCCZwRERERERECoIJ3P9r797joq7zPY6/BwhF4Jh2NNb7rSiFkNZrkhQHzAjb1E1JZU0tMSlXzZNpbuFjNVPbEAXTvGXmqtG6paZrtXWs1t2HkdesdSVJ0NQ93lAQgYHf+cPj5IgXLjPM/GZez8fDx8P5/n7zm89vPvKV9/wuAwAAAAAmQYADAAAAAJMgwAEAAACASRDgAAAAAMAkCHAAAAAAYBIEOAAAAAAwCQIcAAAAAJgEAQ4AAAAATIIABwAAAAAmYZoA9/XXX+uJJ55QRESEoqKi9Pvf/15FRUW25V999ZUGDhyoiIgIxcTEaPny5S6sFgAAAAAczxQBbvfu3RoxYoSa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aGioFi5c6OJqq2bXrl1KTk6u8vpWq1WDBw926f55cx/279+vp59+Wj169FD37t01atQoff/993VQYWXe3Ie9e/cqKSlJ9957r3r16qUZM2aosLCwDip0Lm/u6WXMcc7BHOcevH2OA8zAz9UFeKKQkBClp6dfc1mHDh3quJrae//995WTk1OldUtLSzVlyhTt3r1b0dHRTq7sxryxD4cPH9awYcMUFhammTNnymKxaPny5RoyZIg++OADtW7duo6q/Zk39uHQoUN68sknFRkZqfT0dJ08eVKvv/66Dh8+rCVLltRRpc7jjT29jDnOeZjj3ANzHOD+CHBO4O/vr86dO7u6jDq3d+9epaam6ujRo64uRZJ39uHdd99VQECAFi9erAYNGkiSevTooZiYGL377rt66aWX6rwmb+1D/fr1lZmZqfr160u6dErSlClTlJeXp1atWrm4wtrxxp5KzHHugDnOPXj6HAe4O06hdAPr169XaGiojh8/bjceExNj+8/o1Vdf1V133aXs7Gzb8tWrVys0NFSffvrpdbe9cuVK9e3bV+Hh4br//vuVmppqd4pDRUWFFi1apNjYWIWFhalv377KysqyLX/xxRf1/vvv6+jRowoNDdX69euv+1rjx49X48aN9f7771f7PXAHntCH9u3ba+TIkbZfbCSpQYMGCgkJUX5+fvXeEBfxhD6MGTNGy5Yts/1iI0m33HKLJKmkpKQa74Zn8ISeSsxx7tAH5jj36ANzHOBaHIFzEqvVWmnM19dXFoulRtubOHGitm3bptTUVP35z3/WsWPH9Prrr+vxxx9XbGzsNZ+zadMmzZ07V5MnT1ZoaKgOHTqk2bNnq6SkRLNmzZIkpaamav369XrmmWcUERGhv/3tb/rd736nixcvKikpSWPHjlVBQYH27dunjIyMG36qtmjRIt1555012j9n8bY+JCYmVho7fPiwDh48qKioqBrtsyN4Wx+aNm2qpk2bSpIuXLig3bt3Ky0tTffee6/uuOOOGu2zu/G2nkrMce7QB+Y49+iDN8xxgDsjwDlBXl6eOnXqVGk8NTVVTzzxRI22Wb9+fc2cOVNJSUlasWKFvvjiC/3nf/6npkyZct3n7NixQy1atNDQoUPl4+Ojbt26qUGDBiooKJAk5ebm6r333tMLL7ygkSNHSpKioqJUXl6u9PR0/frXv1arVq3U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\n"
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "sns.catplot(x=\"index\", y=\"value\", hue=\"kind\", col=\"variable\", kind=\"bar\", data=df_reconstr_comp, height=5, aspect=1, col_wrap=2)\n",
    "plt.savefig(\"flux_set_comparison.svg\")"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "# Create class based method"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 205,
   "outputs": [],
   "source": [
    "class ConvexKinetics:\n",
    "\n",
    "    def __init__(self, S_matrix):\n",
    "\n",
    "        self.regulation = False # TODO make this in a better way\n",
    "        self.loss = 0\n",
    "        self.constraints = []\n",
    "\n",
    "        self.n_met = len(S_matrix.index)\n",
    "        self.n_rxn = len(S_matrix.columns)\n",
    "\n",
    "        S_mol = np.array(S_matrix)   # has molecularity\n",
    "        self.S = np.sign(S_mol)      # has only +1 and -1 stoichiometries\n",
    "\n",
    "        self.S_s, self.S_p = -np.copy(self.S), np.copy(self.S) # reverse neg sign\n",
    "        self.S_s[self.S > 0] = 0 # zeros products\n",
    "        self.S_p[self.S < 0] = 0 # zeros substrates\n",
    "\n",
    "        self.S_s_nz = np.array(self.S_s.nonzero())    # substrate indices (metabolite, reaction)\n",
    "        self.S_p_nz = np.array(self.S_p.nonzero())    # product indices (metabolite, reaction)\n",
    "        self.S_s_mol = np.abs(S_mol)[self.S_s.nonzero()]  # substrate molecularity at indices\n",
    "        self.S_p_mol = np.abs(S_mol)[self.S_p.nonzero()]  # product molecularity at indices\n",
    "\n",
    "        # TODO Refactor all the below lines as one liners\n",
    "        # first coordinate, e.g. metabolites w nonzero substrate/product coeff across all reactions. also works as substrate indices.\n",
    "        self.met_s_nz, self.met_p_nz = self.S_s_nz[0, :], self.S_p_nz[0, :]     #\n",
    "\n",
    "        # second coordinate, e.g. reactions indices for those concentrations. works to index substrates as well.\n",
    "        self.rxn_s_nz, self.rxn_p_nz = self.S_s_nz[1, :], self.S_p_nz[1, :]\n",
    "\n",
    "        # one dim is always 2\n",
    "        n_Km_s, n_Km_p = len(self.met_s_nz), len(self.met_p_nz) # number of substrate and product Km\n",
    "\n",
    "        self.Km_s, self.Km_p = cp.Variable(n_Km_s), cp.Variable(n_Km_p) # substrate and product Km\n",
    "        self.cfwd, self.crev = cp.Variable(n_rxn), cp.Variable(n_rxn) # forward and reverse reaction rate constants\n",
    "\n",
    "    def add_regulation(self, regulation_matrix):\n",
    "\n",
    "        # TODO Assert that regulation matrix has same order of metabolites as S matrix\n",
    "\n",
    "        Sr = regulation_matrix\n",
    "\n",
    "        self.S_i = np.copy(np.array(Sr) == -1) # reaction direction does not matter\n",
    "        self.S_a = np.copy(np.array(Sr) == 1)\n",
    "\n",
    "        S_i_nz = np.array(self.S_i.nonzero())\n",
    "        S_a_nz = np.array(self.S_a.nonzero())\n",
    "\n",
    "        self.met_i_nz, self.met_a_nz = S_i_nz[0, :], S_a_nz[0, :]\n",
    "        self.rxn_i_nz, self.rxn_a_nz = S_i_nz[1, :], S_a_nz[1, :]\n",
    "\n",
    "        n_Km_i, n_Km_a = len(self.met_i_nz), len(self.met_a_nz)\n",
    "        self.Km_i = cp.Variable(n_Km_i) if n_Km_i else None\n",
    "        self.Km_a = cp.Variable(n_Km_a) if n_Km_a else None\n",
    "\n",
    "        self.regulation = True\n",
    "\n",
    "    def add_flow_data(self, flow_data):\n",
    "\n",
    "        # TODO assert flux columns are identical to S_matrix columns\n",
    "        self.n_flux_set = len(flow_data.index)\n",
    "        self.flow_data = np.array(flow_data)\n",
    "\n",
    "        self.c = cp.Variable([self.n_met, self.n_flux_set])    # concentrations\n",
    "\n",
    "        y_s_t, y_p_t, y_i_t, y_a_t = [], [], [], []\n",
    "\n",
    "        # define Km positions by nonzero S matrix concentrations. Activation is reverse val of inhibition.\n",
    "        for i in range(self.n_flux_set):\n",
    "            y_s_t.append(cp.multiply(self.S_s_mol, self.c[self.met_s_nz, i] - self.Km_s))\n",
    "            y_p_t.append(cp.multiply(self.S_p_mol, self.c[self.met_p_nz, i] - self.Km_p))\n",
    "            y_i_t.append(self.c[self.met_i_nz, i] - self.Km_i if self.Km_i else None)\n",
    "            y_a_t.append(-(self.c[self.met_a_nz, i] - self.Km_a) if self.Km_a else None)\n",
    "\n",
    "        self.y_s, self.y_p, self.y_i, self.y_a = cp.vstack(y_s_t), cp.vstack(y_p_t), cp.vstack(y_i_t), cp.vstack(y_a_t)\n",
    "\n",
    "        y_f_vec, y_r_vec = [self.y_s], [self.y_p]\n",
    "        if self.Km_i:\n",
    "            y_f_vec.append(self.y_i)\n",
    "            y_r_vec.append(self.y_i)\n",
    "        if self.Km_a:\n",
    "            y_f_vec.append(self.y_a)\n",
    "            y_r_vec.append(self.y_a)\n",
    "\n",
    "        self.y_f, self.y_r = cp.hstack(y_f_vec), cp.hstack(y_r_vec)\n",
    "\n",
    "    def construct_binding_matrix(self):\n",
    "\n",
    "        # number of saturation terms for sub, prod\n",
    "        # make the code below cleaner\n",
    "        S_s_comb = np.concatenate((self.S_s, self.S_i, self.S_a), axis=0)  if self.regulation else self.S_s\n",
    "        S_p_comb = np.concatenate((self.S_p, self.S_i, self.S_a), axis=0) if self.regulation else self.S_p\n",
    "        n_alpha = np.sum(np.power(2, np.sign(S_s_comb).sum(axis=0)) - 1)\n",
    "        n_beta = np.sum(np.power(2, np.sign(S_p_comb).sum(axis=0)) - 1)\n",
    "\n",
    "        # saturation matrix setup, first sub, then inhib, then act.\n",
    "        C_alpha = np.zeros([n_alpha, len(self.met_s_nz) + len(self.met_i_nz) + len(self.met_a_nz)])\n",
    "        C_beta = np.zeros([n_beta, len(self.met_p_nz) + len(self.met_i_nz) + len(self.met_a_nz)])\n",
    "\n",
    "        # to separate different reactions saturation terms to their individual reaction equations.\n",
    "        d_alpha, d_beta = np.zeros(n_alpha, dtype=np.int8), np.zeros(n_beta, dtype=np.int8)\n",
    "\n",
    "        s_idx, p_idx = 0, 0\n",
    "\n",
    "        for i in range(n_rxn):\n",
    "            # pick one reaction at a time (get substrate indicies)\n",
    "            idx_s_cur_rxn = np.concatenate((self.rxn_s_nz == i, self.rxn_i_nz == i, self.rxn_a_nz == i))\n",
    "            idx_p_cur_rxn = np.concatenate((self.rxn_p_nz == i, self.rxn_i_nz == i, self.rxn_a_nz == i))\n",
    "\n",
    "            # generates all binary permutations minus the first one since that would result in -1\n",
    "            s_sat_perm = np.array(list(itertools.product([0, 1], repeat=sum(idx_s_cur_rxn))))[1:, :]\n",
    "            p_sat_perm = np.array(list(itertools.product([0, 1], repeat=sum(idx_p_cur_rxn))))[1:, :]\n",
    "\n",
    "            r_s, _ = s_sat_perm.shape\n",
    "            r_p, _ = p_sat_perm.shape\n",
    "\n",
    "            # replace zeros with saturation matrix\n",
    "            C_alpha[s_idx:(s_idx+r_s), idx_s_cur_rxn] = s_sat_perm\n",
    "            d_alpha[s_idx:(s_idx+r_s)] = i\n",
    "\n",
    "            C_beta[p_idx:(p_idx+r_p), idx_p_cur_rxn] = p_sat_perm\n",
    "            d_beta[p_idx:(p_idx+r_p)] = i\n",
    "\n",
    "            s_idx += r_s # add number of rows added.\n",
    "            p_idx += r_p #\n",
    "\n",
    "        self.C_alpha, self.C_beta, self.d_alpha, self.d_beta = C_alpha, C_beta, d_alpha, d_beta\n",
    "\n",
    "    def construct_kinetic_objective(self):\n",
    "\n",
    "        # TODO\n",
    "        LSE_expr, denom_expr = [], []\n",
    "\n",
    "        sign = np.sign(self.flow_data)\n",
    "        lvE = np.log(sign * self.flow_data)\n",
    "\n",
    "        for j in range(self.n_flux_set):\n",
    "            for i in range(self.n_rxn):\n",
    "                # sum terms are separate in logsumexp. one per saturation term (row in C_alpha, C_beta)\n",
    "\n",
    "                Km_s_idx = np.nonzero(self.rxn_s_nz == i) # TODO have to set as attribute\n",
    "                S_s_idx = self.S_s_nz[0, self.rxn_s_nz == i] # negate -1 entries\n",
    "\n",
    "                Km_p_idx = np.nonzero(self.rxn_p_nz == i)\n",
    "                S_p_idx = self.S_p_nz[0, self.rxn_p_nz == i]\n",
    "\n",
    "                if sign[j, i] == 1:\n",
    "                    expr_num = [\n",
    "                                lvE[j, i] + (self.C_alpha @ cp.vec(self.y_f[j, :]))[self.d_alpha == i],\n",
    "                                lvE[j, i] + (self.C_beta @ cp.vec(self.y_r[j, :]))[self.d_beta == i],\n",
    "                                lvE[j, i] + 0,\n",
    "                                self.S.T[i, S_p_idx] @ cp.vec(self.y_p[j, Km_p_idx])  + self.crev[i] # TODO did removing multiply break this?\n",
    "                                ] # TODO first three terms are the same. can be combined outside if statement\n",
    "\n",
    "                    expr_denom = - (- self.S.T[i, S_s_idx] @ cp.vec(self.y_s[j, Km_s_idx])) - self.cfwd[i]\n",
    "                    expr = cp.hstack(expr_num) + expr_denom # TODO this might be wrong\n",
    "                    LSE_expr.append(expr) # TODO vectorize this\n",
    "\n",
    "                    denom_expr.append(-expr_denom) # TODO vectorize this\n",
    "\n",
    "\n",
    "                # keep saturation term the same, switch around fwd and rev terms. flip all signs with S matrix since it's signed.\n",
    "                if sign[j, i] == -1:\n",
    "                    expr_num = [\n",
    "                                lvE[j, i] + (self.C_alpha @ cp.vec(self.y_f[j, :]))[self.d_alpha == i],\n",
    "                                lvE[j, i] + (self.C_beta @ cp.vec(self.y_r[j, :]))[self.d_beta == i],\n",
    "                                lvE[j, i] + 0,\n",
    "                                - self.S.T[i, S_s_idx] @ cp.vec(self.y_s[j, Km_s_idx]) + self.cfwd[i]\n",
    "                                ]\n",
    "\n",
    "                    expr_denom = - (self.S.T[i, S_p_idx] @ cp.vec(self.y_p[j, Km_p_idx])) - self.crev[i]\n",
    "                    expr = cp.hstack(expr_num) + expr_denom # TODO this might be wrong\n",
    "\n",
    "                    LSE_expr.append(expr)\n",
    "\n",
    "                    denom_expr.append(cp.multiply(np.ones(1), S.T[i, S_p_idx] @ cp.vec(y_p[j, Km_p_idx])) + crev[i])\n",
    "\n",
    "            self.LSE_expr, self.denom_expr = LSE_expr, denom_expr\n",
    "\n",
    "    def create_objective_function(self, prior_weight = 0.0001, l1_weight = 0.0001, denom_weight = 0.01):\n",
    "\n",
    "        p = prior_weight\n",
    "        l1 = l1_weight\n",
    "        l1_term =  cp.sum(cp.hstack([self.cfwd, self.crev, cp.vec(self.c)])) + cp.sum(cp.hstack([-self.Km_s, -self.Km_p])) # regularization (l1 because geometric)\n",
    "        p_term = cp.norm1(cp.hstack([self.cfwd, self.crev, cp.vec(self.c)])) + cp.norm1(cp.hstack([-self.Km_s, -self.Km_p])) # regularization # TODO these are conflicting also prior\n",
    "\n",
    "        if self.Km_i is not None:\n",
    "            l1_term += cp.sum(cp.hstack([-self.Km_i]))\n",
    "        if self.Km_a is not None:\n",
    "            l1_term += cp.sum(cp.hstack([-self.Km_a])) # TODO this might break if no Km\n",
    "\n",
    "        for i in range(len(self.LSE_expr)):\n",
    "            self.loss += cp.norm1(cp.pos(cp.log_sum_exp(self.LSE_expr[i])))\n",
    "        for i in range(len(self.denom_expr)):\n",
    "            self.loss += denom_weight * self.denom_expr[i]\n",
    "\n",
    "        self.loss += l1 * l1_term + p * p_term\n",
    "\n",
    "    def set_parameter_bounds(self, lower_bound = -12, upper_bound = 12):\n",
    "\n",
    "        self.constraints.append(cp.hstack([self.cfwd, self.crev, cp.vec(self.c), self.Km_s, self.Km_p]) >= lower_bound)\n",
    "        self.constraints.append(cp.hstack([self.cfwd, self.crev, cp.vec(self.c), self.Km_s, self.Km_p]) <= upper_bound) # TODO might be append lol\n",
    "\n",
    "        if self.Km_i:\n",
    "            self.constraints.extend([self.Km_i >= -lower_bound, self.Km_i <= upper_bound])\n",
    "        if self.Km_a:\n",
    "            self.constraints.extend([self.Km_a >= -lower_bound, self.Km_a <= upper_bound])\n",
    "\n",
    "    def add_mechanistic_constraints(self, K_eq):\n",
    "\n",
    "        # TODO Assert that order of K_eq is the same as order of self.S (dict)\n",
    "        sign = np.sign(self.flow_data)\n",
    "        haldane = []\n",
    "        fwd_flux = []\n",
    "\n",
    "        for i, r in enumerate(self.S.T):    # TODO do this for kinetic objective creation\n",
    "            Km_s_idx = np.nonzero(self.rxn_s_nz == i) # TODO have to set as attribute\n",
    "            S_s_idx = self.S_s_nz[0, self.rxn_s_nz == i] # negate -1 entries\n",
    "\n",
    "            Km_p_idx = np.nonzero(self.rxn_p_nz == i)\n",
    "            S_p_idx = self.S_p_nz[0, self.rxn_p_nz == i]\n",
    "\n",
    "            haldane.append(K_eq[i] == self.cfwd[i] - self.crev[i] + r[S_p_idx] @ self.Km_p[Km_p_idx] - (-r[S_s_idx]) @ self.Km_s[Km_s_idx])\n",
    "\n",
    "        for j in range(self.n_flux_set):\n",
    "            for i, r in enumerate(self.S.T): # TODO use the above for loop\n",
    "                Km_s_idx = np.nonzero(self.rxn_s_nz == i) # TODO have to set as attribute\n",
    "                S_s_idx = self.S_s_nz[0, self.rxn_s_nz == i] # negate -1 entries\n",
    "\n",
    "                Km_p_idx = np.nonzero(self.rxn_p_nz == i)\n",
    "                S_p_idx = self.S_p_nz[0, self.rxn_p_nz == i]\n",
    "\n",
    "                if sign[j, i] == 1:\n",
    "                    fwd_flux.append(self.cfwd[i] + (-r[S_s_idx]) @ cp.vec(self.y_s[j, Km_s_idx])\n",
    "                                    - (self.crev[i] + r[S_p_idx] @ cp.vec(self.y_p[j, Km_p_idx]))  >= 0)  # add minus since s matrix has minus\n",
    "\n",
    "                if sign[j, i] == -1:\n",
    "                    fwd_flux.append(self.cfwd[i] + (-r[S_s_idx]) @ cp.vec(self.y_s[j, Km_s_idx])\n",
    "                                    - (self.crev[i] + r[S_p_idx] @ cp.vec(self.y_p[j, Km_p_idx]))  <= 0)  # add minus since s matrix has minus\n",
    "\n",
    "            self.constraints.extend([cp.multiply(self.S.T @ cp.vec(self.c[:, j]), sign[j, :])  <= cp.multiply(K_eq, sign[j, :])])\n",
    "\n",
    "        self.constraints.extend(haldane)\n",
    "        self.constraints.extend(fwd_flux)\n",
    "\n",
    "    def solve(self, solver = cp.ECOS, verbose = False, **kwargs):\n",
    "\n",
    "        self.problem = cp.Problem(cp.Minimize(self.loss), self.constraints)\n",
    "        self.problem.solve(solver = solver, verbose = verbose, **kwargs)\n"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 206,
   "outputs": [],
   "source": [
    "E = ConvexKinetics(Sd)"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 207,
   "outputs": [],
   "source": [
    "E.add_regulation(Sr)"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 208,
   "outputs": [],
   "source": [
    "E.add_flow_data(pd.DataFrame(np.array([vE])))"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 209,
   "outputs": [],
   "source": [
    "E.construct_binding_matrix()"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 210,
   "outputs": [],
   "source": [
    "E.construct_kinetic_objective()"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 211,
   "outputs": [],
   "source": [
    "E.create_objective_function()"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 212,
   "outputs": [],
   "source": [
    "E.set_parameter_bounds()"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 213,
   "outputs": [],
   "source": [
    "E.add_mechanistic_constraints(K_eq)"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 215,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "===============================================================================\n",
      "                                     CVXPY                                     \n",
      "                                     v1.3.0                                    \n",
      "===============================================================================\n",
      "(CVXPY) Apr 18 09:57:18 AM: Your problem has 33 variables, 13 constraints, and 0 parameters.\n",
      "(CVXPY) Apr 18 09:57:18 AM: It is compliant with the following grammars: DCP, DQCP\n",
      "(CVXPY) Apr 18 09:57:18 AM: (If you need to solve this problem multiple times, but with different data, consider using parameters.)\n",
      "(CVXPY) Apr 18 09:57:18 AM: CVXPY will first compile your problem; then, it will invoke a numerical solver to obtain a solution.\n",
      "-------------------------------------------------------------------------------\n",
      "                                  Compilation                                  \n",
      "-------------------------------------------------------------------------------\n",
      "(CVXPY) Apr 18 09:57:18 AM: Compiling problem (target solver=ECOS).\n",
      "(CVXPY) Apr 18 09:57:18 AM: Reduction chain: Dcp2Cone -> CvxAttr2Constr -> ConeMatrixStuffing -> ECOS\n",
      "(CVXPY) Apr 18 09:57:18 AM: Applying reduction Dcp2Cone\n",
      "(CVXPY) Apr 18 09:57:18 AM: Applying reduction CvxAttr2Constr\n",
      "(CVXPY) Apr 18 09:57:18 AM: Applying reduction ConeMatrixStuffing\n",
      "(CVXPY) Apr 18 09:57:18 AM: Applying reduction ECOS\n",
      "(CVXPY) Apr 18 09:57:18 AM: Finished problem compilation (took 5.108e-02 seconds).\n",
      "-------------------------------------------------------------------------------\n",
      "                                Numerical solver                               \n",
      "-------------------------------------------------------------------------------\n",
      "(CVXPY) Apr 18 09:57:18 AM: Invoking solver ECOS  to obtain a solution.\n",
      "-------------------------------------------------------------------------------\n",
      "                                    Summary                                    \n",
      "-------------------------------------------------------------------------------\n",
      "(CVXPY) Apr 18 09:57:18 AM: Problem status: optimal\n",
      "(CVXPY) Apr 18 09:57:18 AM: Optimal value: 1.840e-01\n",
      "(CVXPY) Apr 18 09:57:18 AM: Compilation took 5.108e-02 seconds\n",
      "(CVXPY) Apr 18 09:57:18 AM: Solver (including time spent in interface) took 3.331e-03 seconds\n"
     ]
    }
   ],
   "source": [
    "E.solve(verbose=True)"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 132,
   "outputs": [
    {
     "data": {
      "text/plain": "                             6PFRUCTPHOS-RXN  F16ALDOLASE-RXN  2TRANSKETO-RXN  \\\nFRUCTOSE-6P                                1                0               0   \nATP                                        0                0               0   \nPROTON                                     0                0               0   \nADP                                        1                0               0   \nFRUCTOSE-16-DIPHOSPHATE                    0                0               0   \nDIHYDROXY-ACETONE-PHOSPHATE                0                0               0   \nGAP                                        0                0               0   \nERYTHROSE-4P                               0                0               0   \nXYLULOSE-5-PHOSPHATE                       0                0               0   \n\n                             TRIOSEPISOMERIZATION-RXN  \nFRUCTOSE-6P                                         0  \nATP                                                 0  \nPROTON                                              0  \nADP                                                 0  \nFRUCTOSE-16-DIPHOSPHATE                             0  \nDIHYDROXY-ACETONE-PHOSPHATE                         0  \nGAP                                                 0  \nERYTHROSE-4P                                        0  \nXYLULOSE-5-PHOSPHATE                                0  ",
      "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>6PFRUCTPHOS-RXN</th>\n      <th>F16ALDOLASE-RXN</th>\n      <th>2TRANSKETO-RXN</th>\n      <th>TRIOSEPISOMERIZATION-RXN</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>FRUCTOSE-6P</th>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ATP</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>PROTON</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ADP</th>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>FRUCTOSE-16-DIPHOSPHATE</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>DIHYDROXY-ACETONE-PHOSPHATE</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>GAP</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>ERYTHROSE-4P</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>XYLULOSE-5-PHOSPHATE</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
     },
     "execution_count": 132,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Sr\n",
    "\n",
    "# define y vecs\n",
    "# make the code below more efficient\n"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "outputs": [],
   "source": [
    "haldane = []\n",
    "fwd_flux = []\n",
    "\n",
    "for i, r in enumerate(S.T):\n",
    "    Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "    S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "\n",
    "    Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "    S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "\n",
    "    haldane.append(K_eq[i] == cfwd[i] - crev[i] + r[S_p_idx] @ Km_p[Km_p_idx] - (-r[S_s_idx]) @ Km_s[Km_s_idx])\n",
    "\n",
    "for j in range(n_flux_set):\n",
    "    for i, r in enumerate(S.T):\n",
    "        Km_s_idx = np.nonzero(S_s_nz[1, :] == i)\n",
    "        S_s_idx = S_s_nz[0, S_s_nz[1, :] == i] # negate -1 entries\n",
    "\n",
    "        Km_p_idx = np.nonzero(S_p_nz[1, :] == i)\n",
    "        S_p_idx = S_p_nz[0, S_p_nz[1, :] == i]\n",
    "\n",
    "        if sign[j, i] == 1:\n",
    "            fwd_flux.append(cfwd[i] + (-r[S_s_idx]) @ cp.vec(y_s[j, Km_s_idx]) - (crev[i] + r[S_p_idx] @ cp.vec(y_p[j, Km_p_idx]))  >= 0)  # add minus since s matrix has minus\n",
    "\n",
    "        if sign[j, i] == -1:\n",
    "            fwd_flux.append(cfwd[i] + (-r[S_s_idx]) @ cp.vec(y_s[j, Km_s_idx]) - (crev[i] + r[S_p_idx] @ cp.vec(y_p[j, Km_p_idx]))  <= 0)  # add minus since s matrix has minus\n",
    "\n",
    "    constr.extend([cp.multiply(S.T @ cp.vec(c[:, j]), sign[j, :])  <= cp.multiply(K_eq, sign[j, :])])\n",
    "\n",
    "constr.extend(haldane)\n",
    "constr.extend(fwd_flux)"
   ],
   "metadata": {
    "collapsed": false
   }
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
